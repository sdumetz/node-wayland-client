[
  {
    "name": "wl_display",
    "version": 1,
    "description": "\n      The core global object.  This is a special singleton object.  It\n      is used for internal Wayland protocol features.\n    ",
    "summary": "core global object",
    "requests": [
      {
        "name": "sync",
        "description": "\n\tThe sync request asks the server to emit the 'done' event\n\ton the returned wl_callback object.  Since requests are\n\thandled in-order and events are delivered in-order, this can\n\tbe used as a barrier to ensure all previous requests and the\n\tresulting events have been handled.\n\n\tThe object returned by this request will be destroyed by the\n\tcompositor after the callback is fired and as such the client must not\n\tattempt to use it after that point.\n\n\tThe callback_data passed in the callback is the event serial.\n      ",
        "summary": "asynchronous roundtrip",
        "args": [
          {
            "name": "callback",
            "type": "new_id",
            "interface": "wl_callback",
            "summary": "callback object for the sync request"
          }
        ]
      },
      {
        "name": "get_registry",
        "description": "\n\tThis request creates a registry object that allows the client\n\tto list and bind the global objects available from the\n\tcompositor.\n\n\tIt should be noted that the server side resources consumed in\n\tresponse to a get_registry request can only be released when the\n\tclient disconnects, not when the client side proxy is destroyed.\n\tTherefore, clients should invoke get_registry as infrequently as\n\tpossible to avoid wasting memory.\n      ",
        "summary": "get global registry object",
        "args": [
          {
            "name": "registry",
            "type": "new_id",
            "interface": "wl_registry",
            "summary": "global registry object"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "error",
        "description": "\n\tThe error event is sent out when a fatal (non-recoverable)\n\terror has occurred.  The object_id argument is the object\n\twhere the error occurred, most often in response to a request\n\tto that object.  The code identifies the error and is defined\n\tby the object interface.  As such, each interface defines its\n\town set of error codes.  The message is a brief description\n\tof the error, for (debugging) convenience.\n      ",
        "summary": "fatal error event",
        "args": [
          {
            "name": "object_id",
            "type": "object",
            "summary": "object where the error occurred"
          },
          {
            "name": "code",
            "type": "uint",
            "summary": "error code"
          },
          {
            "name": "message",
            "type": "string",
            "summary": "error description"
          }
        ]
      },
      {
        "name": "delete_id",
        "description": "\n\tThis event is used internally by the object ID management\n\tlogic. When a client deletes an object that it had created,\n\tthe server will send this event to acknowledge that it has\n\tseen the delete request. When the client receives this event,\n\tit will know that it can safely reuse the object ID.\n      ",
        "summary": "acknowledge object ID deletion",
        "args": [
          {
            "name": "id",
            "type": "uint",
            "summary": "deleted object ID"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "invalid_object",
          "value": 0,
          "summary": "server couldn't find object"
        },
        {
          "name": "invalid_method",
          "value": 1,
          "summary": "method doesn't exist on the specified interface or malformed request"
        },
        {
          "name": "no_memory",
          "value": 2,
          "summary": "server is out of memory"
        },
        {
          "name": "implementation",
          "value": 3,
          "summary": "implementation error in compositor"
        }
      ]
    }
  },
  {
    "name": "wl_registry",
    "version": 1,
    "description": "\n      The singleton global registry object.  The server has a number of\n      global objects that are available to all clients.  These objects\n      typically represent an actual object in the server (for example,\n      an input device) or they are singleton objects that provide\n      extension functionality.\n\n      When a client creates a registry object, the registry object\n      will emit a global event for each global currently in the\n      registry.  Globals come and go as a result of device or\n      monitor hotplugs, reconfiguration or other events, and the\n      registry will send out global and global_remove events to\n      keep the client up to date with the changes.  To mark the end\n      of the initial burst of events, the client can use the\n      wl_display.sync request immediately after calling\n      wl_display.get_registry.\n\n      A client can bind to a global object by using the bind\n      request.  This creates a client-side handle that lets the object\n      emit events to the client and lets the client invoke requests on\n      the object.\n    ",
    "summary": "global registry object",
    "requests": [
      {
        "name": "bind",
        "description": "\n\tBinds a new, client-created object to the server using the\n\tspecified name as the identifier.\n      ",
        "summary": "bind an object to the display",
        "args": [
          {
            "name": "name",
            "type": "uint",
            "summary": "unique numeric name of the object"
          },
          {
            "name": "id",
            "type": "new_id",
            "summary": "bounded object"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "global",
        "description": "\n\tNotify the client of global objects.\n\n\tThe event notifies the client that a global object with\n\tthe given name is now available, and it implements the\n\tgiven version of the given interface.\n      ",
        "summary": "announce global object",
        "args": [
          {
            "name": "name",
            "type": "uint",
            "summary": "numeric name of the global object"
          },
          {
            "name": "interface",
            "type": "string",
            "summary": "interface implemented by the object"
          },
          {
            "name": "version",
            "type": "uint",
            "summary": "interface version"
          }
        ]
      },
      {
        "name": "global_remove",
        "description": "\n\tNotify the client of removed global objects.\n\n\tThis event notifies the client that the global identified\n\tby name is no longer available.  If the client bound to\n\tthe global using the bind request, the client should now\n\tdestroy that object.\n\n\tThe object remains valid and requests to the object will be\n\tignored until the client destroys it, to avoid races between\n\tthe global going away and a client sending a request to it.\n      ",
        "summary": "announce removal of global object",
        "args": [
          {
            "name": "name",
            "type": "uint",
            "summary": "numeric name of the global object"
          }
        ]
      }
    ],
    "enums": {}
  },
  {
    "name": "wl_callback",
    "version": 1,
    "description": "\n      Clients can handle the 'done' event to get notified when\n      the related request is done.\n    ",
    "summary": "callback object",
    "requests": [],
    "events": [
      {
        "name": "done",
        "description": "\n\tNotify the client when the related request is done.\n      ",
        "summary": "done event",
        "args": [
          {
            "name": "callback_data",
            "type": "uint",
            "summary": "request-specific data for the callback"
          }
        ]
      }
    ],
    "enums": {}
  },
  {
    "name": "wl_compositor",
    "version": 4,
    "description": "\n      A compositor.  This object is a singleton global.  The\n      compositor is in charge of combining the contents of multiple\n      surfaces into one displayable output.\n    ",
    "summary": "the compositor singleton",
    "requests": [
      {
        "name": "create_surface",
        "description": "\n\tAsk the compositor to create a new surface.\n      ",
        "summary": "create new surface",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_surface",
            "summary": "the new surface"
          }
        ]
      },
      {
        "name": "create_region",
        "description": "\n\tAsk the compositor to create a new region.\n      ",
        "summary": "create new region",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_region",
            "summary": "the new region"
          }
        ]
      }
    ],
    "events": [],
    "enums": {}
  },
  {
    "name": "wl_shm_pool",
    "version": 1,
    "description": "\n      The wl_shm_pool object encapsulates a piece of memory shared\n      between the compositor and client.  Through the wl_shm_pool\n      object, the client can allocate shared memory wl_buffer objects.\n      All objects created through the same pool share the same\n      underlying mapped memory. Reusing the mapped memory avoids the\n      setup/teardown overhead and is useful when interactively resizing\n      a surface or for many small buffers.\n    ",
    "summary": "a shared memory pool",
    "requests": [
      {
        "name": "create_buffer",
        "description": "\n\tCreate a wl_buffer object from the pool.\n\n\tThe buffer is created offset bytes into the pool and has\n\twidth and height as specified.  The stride argument specifies\n\tthe number of bytes from the beginning of one row to the beginning\n\tof the next.  The format is the pixel format of the buffer and\n\tmust be one of those advertised through the wl_shm.format event.\n\n\tA buffer will keep a reference to the pool it was created from\n\tso it is valid to destroy the pool immediately after creating\n\ta buffer from it.\n      ",
        "summary": "create a buffer from the pool",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_buffer",
            "summary": "buffer to create"
          },
          {
            "name": "offset",
            "type": "int",
            "summary": "buffer byte offset within the pool"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "buffer width, in pixels"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "buffer height, in pixels"
          },
          {
            "name": "stride",
            "type": "int",
            "summary": "number of bytes from the beginning of one row to the beginning of the next row"
          },
          {
            "name": "format",
            "type": "uint",
            "enum": "wl_shm.format",
            "summary": "buffer pixel format"
          }
        ]
      },
      {
        "name": "destroy",
        "description": "\n\tDestroy the shared memory pool.\n\n\tThe mmapped memory will be released when all\n\tbuffers that have been created from this pool\n\tare gone.\n      ",
        "summary": "destroy the pool",
        "args": []
      },
      {
        "name": "resize",
        "description": "\n\tThis request will cause the server to remap the backing memory\n\tfor the pool from the file descriptor passed when the pool was\n\tcreated, but using the new size.  This request can only be\n\tused to make the pool bigger.\n      ",
        "summary": "change the size of the pool mapping",
        "args": [
          {
            "name": "size",
            "type": "int",
            "summary": "new size of the pool, in bytes"
          }
        ]
      }
    ],
    "events": [],
    "enums": {}
  },
  {
    "name": "wl_shm",
    "version": 1,
    "description": "\n      A singleton global object that provides support for shared\n      memory.\n\n      Clients can create wl_shm_pool objects using the create_pool\n      request.\n\n      At connection setup time, the wl_shm object emits one or more\n      format events to inform clients about the valid pixel formats\n      that can be used for buffers.\n    ",
    "summary": "shared memory support",
    "requests": [
      {
        "name": "create_pool",
        "description": "\n\tCreate a new wl_shm_pool object.\n\n\tThe pool can be used to create shared memory based buffer\n\tobjects.  The server will mmap size bytes of the passed file\n\tdescriptor, to use as backing memory for the pool.\n      ",
        "summary": "create a shm pool",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_shm_pool",
            "summary": "pool to create"
          },
          {
            "name": "fd",
            "type": "fd",
            "summary": "file descriptor for the pool"
          },
          {
            "name": "size",
            "type": "int",
            "summary": "pool size, in bytes"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "format",
        "description": "\n\tInforms the client about a valid pixel format that\n\tcan be used for buffers. Known formats include\n\targb8888 and xrgb8888.\n      ",
        "summary": "pixel format description",
        "args": [
          {
            "name": "format",
            "type": "uint",
            "enum": "format",
            "summary": "buffer pixel format"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "invalid_format",
          "value": 0,
          "summary": "buffer format is not known"
        },
        {
          "name": "invalid_stride",
          "value": 1,
          "summary": "invalid size or stride during pool or buffer creation"
        },
        {
          "name": "invalid_fd",
          "value": 2,
          "summary": "mmapping the file descriptor failed"
        }
      ],
      "format": [
        {
          "name": "argb8888",
          "value": 0,
          "summary": "32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"
        },
        {
          "name": "xrgb8888",
          "value": 1,
          "summary": "32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"
        },
        {
          "name": "c8",
          "value": 538982467,
          "summary": "8-bit color index format, [7:0] C"
        },
        {
          "name": "rgb332",
          "value": 943867730,
          "summary": "8-bit RGB format, [7:0] R:G:B 3:3:2"
        },
        {
          "name": "bgr233",
          "value": 944916290,
          "summary": "8-bit BGR format, [7:0] B:G:R 2:3:3"
        },
        {
          "name": "xrgb4444",
          "value": 842093144,
          "summary": "16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"
        },
        {
          "name": "xbgr4444",
          "value": 842089048,
          "summary": "16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"
        },
        {
          "name": "rgbx4444",
          "value": 842094674,
          "summary": "16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"
        },
        {
          "name": "bgrx4444",
          "value": 842094658,
          "summary": "16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"
        },
        {
          "name": "argb4444",
          "value": 842093121,
          "summary": "16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"
        },
        {
          "name": "abgr4444",
          "value": 842089025,
          "summary": "16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"
        },
        {
          "name": "rgba4444",
          "value": 842088786,
          "summary": "16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"
        },
        {
          "name": "bgra4444",
          "value": 842088770,
          "summary": "16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"
        },
        {
          "name": "xrgb1555",
          "value": 892424792,
          "summary": "16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"
        },
        {
          "name": "xbgr1555",
          "value": 892420696,
          "summary": "16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"
        },
        {
          "name": "rgbx5551",
          "value": 892426322,
          "summary": "16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"
        },
        {
          "name": "bgrx5551",
          "value": 892426306,
          "summary": "16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"
        },
        {
          "name": "argb1555",
          "value": 892424769,
          "summary": "16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"
        },
        {
          "name": "abgr1555",
          "value": 892420673,
          "summary": "16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"
        },
        {
          "name": "rgba5551",
          "value": 892420434,
          "summary": "16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"
        },
        {
          "name": "bgra5551",
          "value": 892420418,
          "summary": "16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"
        },
        {
          "name": "rgb565",
          "value": 909199186,
          "summary": "16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"
        },
        {
          "name": "bgr565",
          "value": 909199170,
          "summary": "16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"
        },
        {
          "name": "rgb888",
          "value": 875710290,
          "summary": "24-bit RGB format, [23:0] R:G:B little endian"
        },
        {
          "name": "bgr888",
          "value": 875710274,
          "summary": "24-bit BGR format, [23:0] B:G:R little endian"
        },
        {
          "name": "xbgr8888",
          "value": 875709016,
          "summary": "32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"
        },
        {
          "name": "rgbx8888",
          "value": 875714642,
          "summary": "32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"
        },
        {
          "name": "bgrx8888",
          "value": 875714626,
          "summary": "32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"
        },
        {
          "name": "abgr8888",
          "value": 875708993,
          "summary": "32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"
        },
        {
          "name": "rgba8888",
          "value": 875708754,
          "summary": "32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"
        },
        {
          "name": "bgra8888",
          "value": 875708738,
          "summary": "32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"
        },
        {
          "name": "xrgb2101010",
          "value": 808669784,
          "summary": "32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"
        },
        {
          "name": "xbgr2101010",
          "value": 808665688,
          "summary": "32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"
        },
        {
          "name": "rgbx1010102",
          "value": 808671314,
          "summary": "32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"
        },
        {
          "name": "bgrx1010102",
          "value": 808671298,
          "summary": "32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"
        },
        {
          "name": "argb2101010",
          "value": 808669761,
          "summary": "32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"
        },
        {
          "name": "abgr2101010",
          "value": 808665665,
          "summary": "32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"
        },
        {
          "name": "rgba1010102",
          "value": 808665426,
          "summary": "32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"
        },
        {
          "name": "bgra1010102",
          "value": 808665410,
          "summary": "32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"
        },
        {
          "name": "yuyv",
          "value": 1448695129,
          "summary": "packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"
        },
        {
          "name": "yvyu",
          "value": 1431918169,
          "summary": "packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"
        },
        {
          "name": "uyvy",
          "value": 1498831189,
          "summary": "packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"
        },
        {
          "name": "vyuy",
          "value": 1498765654,
          "summary": "packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"
        },
        {
          "name": "ayuv",
          "value": 1448433985,
          "summary": "packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"
        },
        {
          "name": "nv12",
          "value": 842094158,
          "summary": "2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"
        },
        {
          "name": "nv21",
          "value": 825382478,
          "summary": "2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"
        },
        {
          "name": "nv16",
          "value": 909203022,
          "summary": "2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"
        },
        {
          "name": "nv61",
          "value": 825644622,
          "summary": "2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"
        },
        {
          "name": "yuv410",
          "value": 961959257,
          "summary": "3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"
        },
        {
          "name": "yvu410",
          "value": 961893977,
          "summary": "3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"
        },
        {
          "name": "yuv411",
          "value": 825316697,
          "summary": "3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"
        },
        {
          "name": "yvu411",
          "value": 825316953,
          "summary": "3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"
        },
        {
          "name": "yuv420",
          "value": 842093913,
          "summary": "3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"
        },
        {
          "name": "yvu420",
          "value": 842094169,
          "summary": "3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"
        },
        {
          "name": "yuv422",
          "value": 909202777,
          "summary": "3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"
        },
        {
          "name": "yvu422",
          "value": 909203033,
          "summary": "3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"
        },
        {
          "name": "yuv444",
          "value": 875713881,
          "summary": "3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"
        },
        {
          "name": "yvu444",
          "value": 875714137,
          "summary": "3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"
        },
        {
          "name": "r8",
          "value": 538982482,
          "summary": "[7:0] R"
        },
        {
          "name": "r16",
          "value": 540422482,
          "summary": "[15:0] R little endian"
        },
        {
          "name": "rg88",
          "value": 943212370,
          "summary": "[15:0] R:G 8:8 little endian"
        },
        {
          "name": "gr88",
          "value": 943215175,
          "summary": "[15:0] G:R 8:8 little endian"
        },
        {
          "name": "rg1616",
          "value": 842221394,
          "summary": "[31:0] R:G 16:16 little endian"
        },
        {
          "name": "gr1616",
          "value": 842224199,
          "summary": "[31:0] G:R 16:16 little endian"
        },
        {
          "name": "xrgb16161616f",
          "value": 1211388504,
          "summary": "[63:0] x:R:G:B 16:16:16:16 little endian"
        },
        {
          "name": "xbgr16161616f",
          "value": 1211384408,
          "summary": "[63:0] x:B:G:R 16:16:16:16 little endian"
        },
        {
          "name": "argb16161616f",
          "value": 1211388481,
          "summary": "[63:0] A:R:G:B 16:16:16:16 little endian"
        },
        {
          "name": "abgr16161616f",
          "value": 1211384385,
          "summary": "[63:0] A:B:G:R 16:16:16:16 little endian"
        },
        {
          "name": "xyuv8888",
          "value": 1448434008,
          "summary": "[31:0] X:Y:Cb:Cr 8:8:8:8 little endian"
        },
        {
          "name": "vuy888",
          "value": 875713878,
          "summary": "[23:0] Cr:Cb:Y 8:8:8 little endian"
        },
        {
          "name": "vuy101010",
          "value": 808670550,
          "summary": "Y followed by U then V, 10:10:10. Non-linear modifier only"
        },
        {
          "name": "y210",
          "value": 808530521,
          "summary": "[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"
        },
        {
          "name": "y212",
          "value": 842084953,
          "summary": "[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"
        },
        {
          "name": "y216",
          "value": 909193817,
          "summary": "[63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"
        },
        {
          "name": "y410",
          "value": 808531033,
          "summary": "[31:0] A:Cr:Y:Cb 2:10:10:10 little endian"
        },
        {
          "name": "y412",
          "value": 842085465,
          "summary": "[63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"
        },
        {
          "name": "y416",
          "value": 909194329,
          "summary": "[63:0] A:Cr:Y:Cb 16:16:16:16 little endian"
        },
        {
          "name": "xvyu2101010",
          "value": 808670808,
          "summary": "[31:0] X:Cr:Y:Cb 2:10:10:10 little endian"
        },
        {
          "name": "xvyu12_16161616",
          "value": 909334104,
          "summary": "[63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"
        },
        {
          "name": "xvyu16161616",
          "value": 942954072,
          "summary": "[63:0] X:Cr:Y:Cb 16:16:16:16 little endian"
        },
        {
          "name": "y0l0",
          "value": 810299481,
          "summary": "[63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"
        },
        {
          "name": "x0l0",
          "value": 810299480,
          "summary": "[63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"
        },
        {
          "name": "y0l2",
          "value": 843853913,
          "summary": "[63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"
        },
        {
          "name": "x0l2",
          "value": 843853912,
          "summary": "[63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"
        },
        {
          "name": "yuv420_8bit",
          "value": 942691673
        },
        {
          "name": "yuv420_10bit",
          "value": 808539481
        },
        {
          "name": "xrgb8888_a8",
          "value": 943805016
        },
        {
          "name": "xbgr8888_a8",
          "value": 943800920
        },
        {
          "name": "rgbx8888_a8",
          "value": 943806546
        },
        {
          "name": "bgrx8888_a8",
          "value": 943806530
        },
        {
          "name": "rgb888_a8",
          "value": 943798354
        },
        {
          "name": "bgr888_a8",
          "value": 943798338
        },
        {
          "name": "rgb565_a8",
          "value": 943797586
        },
        {
          "name": "bgr565_a8",
          "value": 943797570
        },
        {
          "name": "nv24",
          "value": 875714126,
          "summary": "non-subsampled Cr:Cb plane"
        },
        {
          "name": "nv42",
          "value": 842290766,
          "summary": "non-subsampled Cb:Cr plane"
        },
        {
          "name": "p210",
          "value": 808530512,
          "summary": "2x1 subsampled Cr:Cb plane, 10 bit per channel"
        },
        {
          "name": "p010",
          "value": 808530000,
          "summary": "2x2 subsampled Cr:Cb plane 10 bits per channel"
        },
        {
          "name": "p012",
          "value": 842084432,
          "summary": "2x2 subsampled Cr:Cb plane 12 bits per channel"
        },
        {
          "name": "p016",
          "value": 909193296,
          "summary": "2x2 subsampled Cr:Cb plane 16 bits per channel"
        },
        {
          "name": "axbxgxrx106106106106",
          "value": 808534593,
          "summary": "[63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian"
        },
        {
          "name": "nv15",
          "value": 892425806,
          "summary": "2x2 subsampled Cr:Cb plane"
        },
        {
          "name": "q410",
          "value": 808531025
        },
        {
          "name": "q401",
          "value": 825242705
        }
      ]
    }
  },
  {
    "name": "wl_buffer",
    "version": 1,
    "description": "\n      A buffer provides the content for a wl_surface. Buffers are\n      created through factory interfaces such as wl_drm, wl_shm or\n      similar. It has a width and a height and can be attached to a\n      wl_surface, but the mechanism by which a client provides and\n      updates the contents is defined by the buffer factory interface.\n    ",
    "summary": "content for a wl_surface",
    "requests": [
      {
        "name": "destroy",
        "description": "\n\tDestroy a buffer. If and how you need to release the backing\n\tstorage is defined by the buffer factory interface.\n\n\tFor possible side-effects to a surface, see wl_surface.attach.\n      ",
        "summary": "destroy a buffer",
        "args": []
      }
    ],
    "events": [
      {
        "name": "release",
        "description": "\n\tSent when this wl_buffer is no longer used by the compositor.\n\tThe client is now free to reuse or destroy this buffer and its\n\tbacking storage.\n\n\tIf a client receives a release event before the frame callback\n\trequested in the same wl_surface.commit that attaches this\n\twl_buffer to a surface, then the client is immediately free to\n\treuse the buffer and its backing storage, and does not need a\n\tsecond buffer for the next surface content update. Typically\n\tthis is possible, when the compositor maintains a copy of the\n\twl_surface contents, e.g. as a GL texture. This is an important\n\toptimization for GL(ES) compositors with wl_shm clients.\n      ",
        "summary": "compositor releases buffer",
        "args": []
      }
    ],
    "enums": {}
  },
  {
    "name": "wl_data_offer",
    "version": 3,
    "description": "\n      A wl_data_offer represents a piece of data offered for transfer\n      by another client (the source client).  It is used by the\n      copy-and-paste and drag-and-drop mechanisms.  The offer\n      describes the different mime types that the data can be\n      converted to and provides the mechanism for transferring the\n      data directly from the source client.\n    ",
    "summary": "offer to transfer data",
    "requests": [
      {
        "name": "accept",
        "description": "\n\tIndicate that the client can accept the given mime type, or\n\tNULL for not accepted.\n\n\tFor objects of version 2 or older, this request is used by the\n\tclient to give feedback whether the client can receive the given\n\tmime type, or NULL if none is accepted; the feedback does not\n\tdetermine whether the drag-and-drop operation succeeds or not.\n\n\tFor objects of version 3 or newer, this request determines the\n\tfinal result of the drag-and-drop operation. If the end result\n\tis that no mime types were accepted, the drag-and-drop operation\n\twill be cancelled and the corresponding drag source will receive\n\twl_data_source.cancelled. Clients may still use this event in\n\tconjunction with wl_data_source.action for feedback.\n      ",
        "summary": "accept one of the offered mime types",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the accept request"
          },
          {
            "name": "mime_type",
            "type": "string",
            "allow-null": "true",
            "summary": "mime type accepted by the client"
          }
        ]
      },
      {
        "name": "receive",
        "description": "\n\tTo transfer the offered data, the client issues this request\n\tand indicates the mime type it wants to receive.  The transfer\n\thappens through the passed file descriptor (typically created\n\twith the pipe system call).  The source client writes the data\n\tin the mime type representation requested and then closes the\n\tfile descriptor.\n\n\tThe receiving client reads from the read end of the pipe until\n\tEOF and then closes its end, at which point the transfer is\n\tcomplete.\n\n\tThis request may happen multiple times for different mime types,\n\tboth before and after wl_data_device.drop. Drag-and-drop destination\n\tclients may preemptively fetch data or examine it more closely to\n\tdetermine acceptance.\n      ",
        "summary": "request that the data is transferred",
        "args": [
          {
            "name": "mime_type",
            "type": "string",
            "summary": "mime type desired by receiver"
          },
          {
            "name": "fd",
            "type": "fd",
            "summary": "file descriptor for data transfer"
          }
        ]
      },
      {
        "name": "destroy",
        "description": "\n\tDestroy the data offer.\n      ",
        "summary": "destroy data offer",
        "args": []
      },
      {
        "name": "finish",
        "description": "\n\tNotifies the compositor that the drag destination successfully\n\tfinished the drag-and-drop operation.\n\n\tUpon receiving this request, the compositor will emit\n\twl_data_source.dnd_finished on the drag source client.\n\n\tIt is a client error to perform other requests than\n\twl_data_offer.destroy after this one. It is also an error to perform\n\tthis request after a NULL mime type has been set in\n\twl_data_offer.accept or no action was received through\n\twl_data_offer.action.\n\n\tIf wl_data_offer.finish request is received for a non drag and drop\n\toperation, the invalid_finish protocol error is raised.\n      ",
        "summary": "the offer will no longer be used",
        "args": []
      },
      {
        "name": "set_actions",
        "description": "\n\tSets the actions that the destination side client supports for\n\tthis operation. This request may trigger the emission of\n\twl_data_source.action and wl_data_offer.action events if the compositor\n\tneeds to change the selected action.\n\n\tThis request can be called multiple times throughout the\n\tdrag-and-drop operation, typically in response to wl_data_device.enter\n\tor wl_data_device.motion events.\n\n\tThis request determines the final result of the drag-and-drop\n\toperation. If the end result is that no action is accepted,\n\tthe drag source will receive wl_data_source.cancelled.\n\n\tThe dnd_actions argument must contain only values expressed in the\n\twl_data_device_manager.dnd_actions enum, and the preferred_action\n\targument must only contain one of those values set, otherwise it\n\twill result in a protocol error.\n\n\tWhile managing an \"ask\" action, the destination drag-and-drop client\n\tmay perform further wl_data_offer.receive requests, and is expected\n\tto perform one last wl_data_offer.set_actions request with a preferred\n\taction other than \"ask\" (and optionally wl_data_offer.accept) before\n\trequesting wl_data_offer.finish, in order to convey the action selected\n\tby the user. If the preferred action is not in the\n\twl_data_offer.source_actions mask, an error will be raised.\n\n\tIf the \"ask\" action is dismissed (e.g. user cancellation), the client\n\tis expected to perform wl_data_offer.destroy right away.\n\n\tThis request can only be made on drag-and-drop offers, a protocol error\n\twill be raised otherwise.\n      ",
        "summary": "set the available/preferred drag-and-drop actions",
        "args": [
          {
            "name": "dnd_actions",
            "type": "uint",
            "summary": "actions supported by the destination client",
            "enum": "wl_data_device_manager.dnd_action"
          },
          {
            "name": "preferred_action",
            "type": "uint",
            "summary": "action preferred by the destination client",
            "enum": "wl_data_device_manager.dnd_action"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "offer",
        "description": "\n\tSent immediately after creating the wl_data_offer object.  One\n\tevent per offered mime type.\n      ",
        "summary": "advertise offered mime type",
        "args": [
          {
            "name": "mime_type",
            "type": "string",
            "summary": "offered mime type"
          }
        ]
      },
      {
        "name": "source_actions",
        "description": "\n\tThis event indicates the actions offered by the data source. It\n\twill be sent right after wl_data_device.enter, or anytime the source\n\tside changes its offered actions through wl_data_source.set_actions.\n      ",
        "summary": "notify the source-side available actions",
        "args": [
          {
            "name": "source_actions",
            "type": "uint",
            "summary": "actions offered by the data source",
            "enum": "wl_data_device_manager.dnd_action"
          }
        ]
      },
      {
        "name": "action",
        "description": "\n\tThis event indicates the action selected by the compositor after\n\tmatching the source/destination side actions. Only one action (or\n\tnone) will be offered here.\n\n\tThis event can be emitted multiple times during the drag-and-drop\n\toperation in response to destination side action changes through\n\twl_data_offer.set_actions.\n\n\tThis event will no longer be emitted after wl_data_device.drop\n\thappened on the drag-and-drop destination, the client must\n\thonor the last action received, or the last preferred one set\n\tthrough wl_data_offer.set_actions when handling an \"ask\" action.\n\n\tCompositors may also change the selected action on the fly, mainly\n\tin response to keyboard modifier changes during the drag-and-drop\n\toperation.\n\n\tThe most recent action received is always the valid one. Prior to\n\treceiving wl_data_device.drop, the chosen action may change (e.g.\n\tdue to keyboard modifiers being pressed). At the time of receiving\n\twl_data_device.drop the drag-and-drop destination must honor the\n\tlast action received.\n\n\tAction changes may still happen after wl_data_device.drop,\n\tespecially on \"ask\" actions, where the drag-and-drop destination\n\tmay choose another action afterwards. Action changes happening\n\tat this stage are always the result of inter-client negotiation, the\n\tcompositor shall no longer be able to induce a different action.\n\n\tUpon \"ask\" actions, it is expected that the drag-and-drop destination\n\tmay potentially choose a different action and/or mime type,\n\tbased on wl_data_offer.source_actions and finally chosen by the\n\tuser (e.g. popping up a menu with the available options). The\n\tfinal wl_data_offer.set_actions and wl_data_offer.accept requests\n\tmust happen before the call to wl_data_offer.finish.\n      ",
        "summary": "notify the selected action",
        "args": [
          {
            "name": "dnd_action",
            "type": "uint",
            "summary": "action selected by the compositor",
            "enum": "wl_data_device_manager.dnd_action"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "invalid_finish",
          "value": 0,
          "summary": "finish request was called untimely"
        },
        {
          "name": "invalid_action_mask",
          "value": 1,
          "summary": "action mask contains invalid values"
        },
        {
          "name": "invalid_action",
          "value": 2,
          "summary": "action argument has an invalid value"
        },
        {
          "name": "invalid_offer",
          "value": 3,
          "summary": "offer doesn't accept this request"
        }
      ]
    }
  },
  {
    "name": "wl_data_source",
    "version": 3,
    "description": "\n      The wl_data_source object is the source side of a wl_data_offer.\n      It is created by the source client in a data transfer and\n      provides a way to describe the offered data and a way to respond\n      to requests to transfer the data.\n    ",
    "summary": "offer to transfer data",
    "requests": [
      {
        "name": "offer",
        "description": "\n\tThis request adds a mime type to the set of mime types\n\tadvertised to targets.  Can be called several times to offer\n\tmultiple types.\n      ",
        "summary": "add an offered mime type",
        "args": [
          {
            "name": "mime_type",
            "type": "string",
            "summary": "mime type offered by the data source"
          }
        ]
      },
      {
        "name": "destroy",
        "description": "\n\tDestroy the data source.\n      ",
        "summary": "destroy the data source",
        "args": []
      },
      {
        "name": "set_actions",
        "description": "\n\tSets the actions that the source side client supports for this\n\toperation. This request may trigger wl_data_source.action and\n\twl_data_offer.action events if the compositor needs to change the\n\tselected action.\n\n\tThe dnd_actions argument must contain only values expressed in the\n\twl_data_device_manager.dnd_actions enum, otherwise it will result\n\tin a protocol error.\n\n\tThis request must be made once only, and can only be made on sources\n\tused in drag-and-drop, so it must be performed before\n\twl_data_device.start_drag. Attempting to use the source other than\n\tfor drag-and-drop will raise a protocol error.\n      ",
        "summary": "set the available drag-and-drop actions",
        "args": [
          {
            "name": "dnd_actions",
            "type": "uint",
            "summary": "actions supported by the data source",
            "enum": "wl_data_device_manager.dnd_action"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "target",
        "description": "\n\tSent when a target accepts pointer_focus or motion events.  If\n\ta target does not accept any of the offered types, type is NULL.\n\n\tUsed for feedback during drag-and-drop.\n      ",
        "summary": "a target accepts an offered mime type",
        "args": [
          {
            "name": "mime_type",
            "type": "string",
            "allow-null": "true",
            "summary": "mime type accepted by the target"
          }
        ]
      },
      {
        "name": "send",
        "description": "\n\tRequest for data from the client.  Send the data as the\n\tspecified mime type over the passed file descriptor, then\n\tclose it.\n      ",
        "summary": "send the data",
        "args": [
          {
            "name": "mime_type",
            "type": "string",
            "summary": "mime type for the data"
          },
          {
            "name": "fd",
            "type": "fd",
            "summary": "file descriptor for the data"
          }
        ]
      },
      {
        "name": "cancelled",
        "description": "\n\tThis data source is no longer valid. There are several reasons why\n\tthis could happen:\n\n\t- The data source has been replaced by another data source.\n\t- The drag-and-drop operation was performed, but the drop destination\n\t  did not accept any of the mime types offered through\n\t  wl_data_source.target.\n\t- The drag-and-drop operation was performed, but the drop destination\n\t  did not select any of the actions present in the mask offered through\n\t  wl_data_source.action.\n\t- The drag-and-drop operation was performed but didn't happen over a\n\t  surface.\n\t- The compositor cancelled the drag-and-drop operation (e.g. compositor\n\t  dependent timeouts to avoid stale drag-and-drop transfers).\n\n\tThe client should clean up and destroy this data source.\n\n\tFor objects of version 2 or older, wl_data_source.cancelled will\n\tonly be emitted if the data source was replaced by another data\n\tsource.\n      ",
        "summary": "selection was cancelled",
        "args": []
      },
      {
        "name": "dnd_drop_performed",
        "description": "\n\tThe user performed the drop action. This event does not indicate\n\tacceptance, wl_data_source.cancelled may still be emitted afterwards\n\tif the drop destination does not accept any mime type.\n\n\tHowever, this event might however not be received if the compositor\n\tcancelled the drag-and-drop operation before this event could happen.\n\n\tNote that the data_source may still be used in the future and should\n\tnot be destroyed here.\n      ",
        "summary": "the drag-and-drop operation physically finished",
        "args": []
      },
      {
        "name": "dnd_finished",
        "description": "\n\tThe drop destination finished interoperating with this data\n\tsource, so the client is now free to destroy this data source and\n\tfree all associated data.\n\n\tIf the action used to perform the operation was \"move\", the\n\tsource can now delete the transferred data.\n      ",
        "summary": "the drag-and-drop operation concluded",
        "args": []
      },
      {
        "name": "action",
        "description": "\n\tThis event indicates the action selected by the compositor after\n\tmatching the source/destination side actions. Only one action (or\n\tnone) will be offered here.\n\n\tThis event can be emitted multiple times during the drag-and-drop\n\toperation, mainly in response to destination side changes through\n\twl_data_offer.set_actions, and as the data device enters/leaves\n\tsurfaces.\n\n\tIt is only possible to receive this event after\n\twl_data_source.dnd_drop_performed if the drag-and-drop operation\n\tended in an \"ask\" action, in which case the final wl_data_source.action\n\tevent will happen immediately before wl_data_source.dnd_finished.\n\n\tCompositors may also change the selected action on the fly, mainly\n\tin response to keyboard modifier changes during the drag-and-drop\n\toperation.\n\n\tThe most recent action received is always the valid one. The chosen\n\taction may change alongside negotiation (e.g. an \"ask\" action can turn\n\tinto a \"move\" operation), so the effects of the final action must\n\talways be applied in wl_data_offer.dnd_finished.\n\n\tClients can trigger cursor surface changes from this point, so\n\tthey reflect the current action.\n      ",
        "summary": "notify the selected action",
        "args": [
          {
            "name": "dnd_action",
            "type": "uint",
            "summary": "action selected by the compositor",
            "enum": "wl_data_device_manager.dnd_action"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "invalid_action_mask",
          "value": 0,
          "summary": "action mask contains invalid values"
        },
        {
          "name": "invalid_source",
          "value": 1,
          "summary": "source doesn't accept this request"
        }
      ]
    }
  },
  {
    "name": "wl_data_device",
    "version": 3,
    "description": "\n      There is one wl_data_device per seat which can be obtained\n      from the global wl_data_device_manager singleton.\n\n      A wl_data_device provides access to inter-client data transfer\n      mechanisms such as copy-and-paste and drag-and-drop.\n    ",
    "summary": "data transfer device",
    "requests": [
      {
        "name": "start_drag",
        "description": "\n\tThis request asks the compositor to start a drag-and-drop\n\toperation on behalf of the client.\n\n\tThe source argument is the data source that provides the data\n\tfor the eventual data transfer. If source is NULL, enter, leave\n\tand motion events are sent only to the client that initiated the\n\tdrag and the client is expected to handle the data passing\n\tinternally. If source is destroyed, the drag-and-drop session will be\n\tcancelled.\n\n\tThe origin surface is the surface where the drag originates and\n\tthe client must have an active implicit grab that matches the\n\tserial.\n\n\tThe icon surface is an optional (can be NULL) surface that\n\tprovides an icon to be moved around with the cursor.  Initially,\n\tthe top-left corner of the icon surface is placed at the cursor\n\thotspot, but subsequent wl_surface.attach request can move the\n\trelative position. Attach requests must be confirmed with\n\twl_surface.commit as usual. The icon surface is given the role of\n\ta drag-and-drop icon. If the icon surface already has another role,\n\tit raises a protocol error.\n\n\tThe current and pending input regions of the icon wl_surface are\n\tcleared, and wl_surface.set_input_region is ignored until the\n\twl_surface is no longer used as the icon surface. When the use\n\tas an icon ends, the current and pending input regions become\n\tundefined, and the wl_surface is unmapped.\n      ",
        "summary": "start drag-and-drop operation",
        "args": [
          {
            "name": "source",
            "type": "object",
            "interface": "wl_data_source",
            "allow-null": "true",
            "summary": "data source for the eventual transfer"
          },
          {
            "name": "origin",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface where the drag originates"
          },
          {
            "name": "icon",
            "type": "object",
            "interface": "wl_surface",
            "allow-null": "true",
            "summary": "drag-and-drop icon surface"
          },
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the implicit grab on the origin"
          }
        ]
      },
      {
        "name": "set_selection",
        "description": "\n\tThis request asks the compositor to set the selection\n\tto the data from the source on behalf of the client.\n\n\tTo unset the selection, set the source to NULL.\n      ",
        "summary": "copy data to the selection",
        "args": [
          {
            "name": "source",
            "type": "object",
            "interface": "wl_data_source",
            "allow-null": "true",
            "summary": "data source for the selection"
          },
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the event that triggered this request"
          }
        ]
      },
      {
        "name": "release",
        "description": "\n\tThis request destroys the data device.\n      ",
        "summary": "destroy data device",
        "args": []
      }
    ],
    "events": [
      {
        "name": "data_offer",
        "description": "\n\tThe data_offer event introduces a new wl_data_offer object,\n\twhich will subsequently be used in either the\n\tdata_device.enter event (for drag-and-drop) or the\n\tdata_device.selection event (for selections).  Immediately\n\tfollowing the data_device_data_offer event, the new data_offer\n\tobject will send out data_offer.offer events to describe the\n\tmime types it offers.\n      ",
        "summary": "introduce a new wl_data_offer",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_data_offer",
            "summary": "the new data_offer object"
          }
        ]
      },
      {
        "name": "enter",
        "description": "\n\tThis event is sent when an active drag-and-drop pointer enters\n\ta surface owned by the client.  The position of the pointer at\n\tenter time is provided by the x and y arguments, in surface-local\n\tcoordinates.\n      ",
        "summary": "initiate drag-and-drop session",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the enter event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "client surface entered"
          },
          {
            "name": "x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          },
          {
            "name": "id",
            "type": "object",
            "interface": "wl_data_offer",
            "allow-null": "true",
            "summary": "source data_offer object"
          }
        ]
      },
      {
        "name": "leave",
        "description": "\n\tThis event is sent when the drag-and-drop pointer leaves the\n\tsurface and the session ends.  The client must destroy the\n\twl_data_offer introduced at enter time at this point.\n      ",
        "summary": "end drag-and-drop session",
        "args": []
      },
      {
        "name": "motion",
        "description": "\n\tThis event is sent when the drag-and-drop pointer moves within\n\tthe currently focused surface. The new position of the pointer\n\tis provided by the x and y arguments, in surface-local\n\tcoordinates.\n      ",
        "summary": "drag-and-drop session motion",
        "args": [
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "drop",
        "description": "\n\tThe event is sent when a drag-and-drop operation is ended\n\tbecause the implicit grab is removed.\n\n\tThe drag-and-drop destination is expected to honor the last action\n\treceived through wl_data_offer.action, if the resulting action is\n\t\"copy\" or \"move\", the destination can still perform\n\twl_data_offer.receive requests, and is expected to end all\n\ttransfers with a wl_data_offer.finish request.\n\n\tIf the resulting action is \"ask\", the action will not be considered\n\tfinal. The drag-and-drop destination is expected to perform one last\n\twl_data_offer.set_actions request, or wl_data_offer.destroy in order\n\tto cancel the operation.\n      ",
        "summary": "end drag-and-drop session successfully",
        "args": []
      },
      {
        "name": "selection",
        "description": "\n\tThe selection event is sent out to notify the client of a new\n\twl_data_offer for the selection for this device.  The\n\tdata_device.data_offer and the data_offer.offer events are\n\tsent out immediately before this event to introduce the data\n\toffer object.  The selection event is sent to a client\n\timmediately before receiving keyboard focus and when a new\n\tselection is set while the client has keyboard focus.  The\n\tdata_offer is valid until a new data_offer or NULL is received\n\tor until the client loses keyboard focus.  The client must\n\tdestroy the previous selection data_offer, if any, upon receiving\n\tthis event.\n      ",
        "summary": "advertise new selection",
        "args": [
          {
            "name": "id",
            "type": "object",
            "interface": "wl_data_offer",
            "allow-null": "true",
            "summary": "selection data_offer object"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "role",
          "value": 0,
          "summary": "given wl_surface has another role"
        }
      ]
    }
  },
  {
    "name": "wl_data_device_manager",
    "version": 3,
    "description": "\n      The wl_data_device_manager is a singleton global object that\n      provides access to inter-client data transfer mechanisms such as\n      copy-and-paste and drag-and-drop.  These mechanisms are tied to\n      a wl_seat and this interface lets a client get a wl_data_device\n      corresponding to a wl_seat.\n\n      Depending on the version bound, the objects created from the bound\n      wl_data_device_manager object will have different requirements for\n      functioning properly. See wl_data_source.set_actions,\n      wl_data_offer.accept and wl_data_offer.finish for details.\n    ",
    "summary": "data transfer interface",
    "requests": [
      {
        "name": "create_data_source",
        "description": "\n\tCreate a new data source.\n      ",
        "summary": "create a new data source",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_data_source",
            "summary": "data source to create"
          }
        ]
      },
      {
        "name": "get_data_device",
        "description": "\n\tCreate a new data device for a given seat.\n      ",
        "summary": "create a new data device",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_data_device",
            "summary": "data device to create"
          },
          {
            "name": "seat",
            "type": "object",
            "interface": "wl_seat",
            "summary": "seat associated with the data device"
          }
        ]
      }
    ],
    "events": [],
    "enums": {
      "dnd_action": [
        {
          "name": "none",
          "value": 0,
          "summary": "no action"
        },
        {
          "name": "copy",
          "value": 1,
          "summary": "copy action"
        },
        {
          "name": "move",
          "value": 2,
          "summary": "move action"
        },
        {
          "name": "ask",
          "value": 4,
          "summary": "ask action"
        }
      ]
    }
  },
  {
    "name": "wl_shell",
    "version": 1,
    "description": "\n      This interface is implemented by servers that provide\n      desktop-style user interfaces.\n\n      It allows clients to associate a wl_shell_surface with\n      a basic surface.\n\n      Note! This protocol is deprecated and not intended for production use.\n      For desktop-style user interfaces, use xdg_shell.\n    ",
    "summary": "create desktop-style surfaces",
    "requests": [
      {
        "name": "get_shell_surface",
        "description": "\n\tCreate a shell surface for an existing surface. This gives\n\tthe wl_surface the role of a shell surface. If the wl_surface\n\talready has another role, it raises a protocol error.\n\n\tOnly one shell surface can be associated with a given surface.\n      ",
        "summary": "create a shell surface from a surface",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_shell_surface",
            "summary": "shell surface to create"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface to be given the shell surface role"
          }
        ]
      }
    ],
    "events": [],
    "enums": {
      "error": [
        {
          "name": "role",
          "value": 0,
          "summary": "given wl_surface has another role"
        }
      ]
    }
  },
  {
    "name": "wl_shell_surface",
    "version": 1,
    "description": "\n      An interface that may be implemented by a wl_surface, for\n      implementations that provide a desktop-style user interface.\n\n      It provides requests to treat surfaces like toplevel, fullscreen\n      or popup windows, move, resize or maximize them, associate\n      metadata like title and class, etc.\n\n      On the server side the object is automatically destroyed when\n      the related wl_surface is destroyed. On the client side,\n      wl_shell_surface_destroy() must be called before destroying\n      the wl_surface object.\n    ",
    "summary": "desktop-style metadata interface",
    "requests": [
      {
        "name": "pong",
        "description": "\n\tA client must respond to a ping event with a pong request or\n\tthe client may be deemed unresponsive.\n      ",
        "summary": "respond to a ping event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the ping event"
          }
        ]
      },
      {
        "name": "move",
        "description": "\n\tStart a pointer-driven move of the surface.\n\n\tThis request must be used in response to a button press event.\n\tThe server may ignore move requests depending on the state of\n\tthe surface (e.g. fullscreen or maximized).\n      ",
        "summary": "start an interactive move",
        "args": [
          {
            "name": "seat",
            "type": "object",
            "interface": "wl_seat",
            "summary": "seat whose pointer is used"
          },
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the implicit grab on the pointer"
          }
        ]
      },
      {
        "name": "resize",
        "description": "\n\tStart a pointer-driven resizing of the surface.\n\n\tThis request must be used in response to a button press event.\n\tThe server may ignore resize requests depending on the state of\n\tthe surface (e.g. fullscreen or maximized).\n      ",
        "summary": "start an interactive resize",
        "args": [
          {
            "name": "seat",
            "type": "object",
            "interface": "wl_seat",
            "summary": "seat whose pointer is used"
          },
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the implicit grab on the pointer"
          },
          {
            "name": "edges",
            "type": "uint",
            "enum": "resize",
            "summary": "which edge or corner is being dragged"
          }
        ]
      },
      {
        "name": "set_toplevel",
        "description": "\n\tMap the surface as a toplevel surface.\n\n\tA toplevel surface is not fullscreen, maximized or transient.\n      ",
        "summary": "make the surface a toplevel surface",
        "args": []
      },
      {
        "name": "set_transient",
        "description": "\n\tMap the surface relative to an existing surface.\n\n\tThe x and y arguments specify the location of the upper left\n\tcorner of the surface relative to the upper left corner of the\n\tparent surface, in surface-local coordinates.\n\n\tThe flags argument controls details of the transient behaviour.\n      ",
        "summary": "make the surface a transient surface",
        "args": [
          {
            "name": "parent",
            "type": "object",
            "interface": "wl_surface",
            "summary": "parent surface"
          },
          {
            "name": "x",
            "type": "int",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "surface-local y coordinate"
          },
          {
            "name": "flags",
            "type": "uint",
            "enum": "transient",
            "summary": "transient surface behavior"
          }
        ]
      },
      {
        "name": "set_fullscreen",
        "description": "\n\tMap the surface as a fullscreen surface.\n\n\tIf an output parameter is given then the surface will be made\n\tfullscreen on that output. If the client does not specify the\n\toutput then the compositor will apply its policy - usually\n\tchoosing the output on which the surface has the biggest surface\n\tarea.\n\n\tThe client may specify a method to resolve a size conflict\n\tbetween the output size and the surface size - this is provided\n\tthrough the method parameter.\n\n\tThe framerate parameter is used only when the method is set\n\tto \"driver\", to indicate the preferred framerate. A value of 0\n\tindicates that the client does not care about framerate.  The\n\tframerate is specified in mHz, that is framerate of 60000 is 60Hz.\n\n\tA method of \"scale\" or \"driver\" implies a scaling operation of\n\tthe surface, either via a direct scaling operation or a change of\n\tthe output mode. This will override any kind of output scaling, so\n\tthat mapping a surface with a buffer size equal to the mode can\n\tfill the screen independent of buffer_scale.\n\n\tA method of \"fill\" means we don't scale up the buffer, however\n\tany output scale is applied. This means that you may run into\n\tan edge case where the application maps a buffer with the same\n\tsize of the output mode but buffer_scale 1 (thus making a\n\tsurface larger than the output). In this case it is allowed to\n\tdownscale the results to fit the screen.\n\n\tThe compositor must reply to this request with a configure event\n\twith the dimensions for the output on which the surface will\n\tbe made fullscreen.\n      ",
        "summary": "make the surface a fullscreen surface",
        "args": [
          {
            "name": "method",
            "type": "uint",
            "enum": "fullscreen_method",
            "summary": "method for resolving size conflict"
          },
          {
            "name": "framerate",
            "type": "uint",
            "summary": "framerate in mHz"
          },
          {
            "name": "output",
            "type": "object",
            "interface": "wl_output",
            "allow-null": "true",
            "summary": "output on which the surface is to be fullscreen"
          }
        ]
      },
      {
        "name": "set_popup",
        "description": "\n\tMap the surface as a popup.\n\n\tA popup surface is a transient surface with an added pointer\n\tgrab.\n\n\tAn existing implicit grab will be changed to owner-events mode,\n\tand the popup grab will continue after the implicit grab ends\n\t(i.e. releasing the mouse button does not cause the popup to\n\tbe unmapped).\n\n\tThe popup grab continues until the window is destroyed or a\n\tmouse button is pressed in any other client's window. A click\n\tin any of the client's surfaces is reported as normal, however,\n\tclicks in other clients' surfaces will be discarded and trigger\n\tthe callback.\n\n\tThe x and y arguments specify the location of the upper left\n\tcorner of the surface relative to the upper left corner of the\n\tparent surface, in surface-local coordinates.\n      ",
        "summary": "make the surface a popup surface",
        "args": [
          {
            "name": "seat",
            "type": "object",
            "interface": "wl_seat",
            "summary": "seat whose pointer is used"
          },
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the implicit grab on the pointer"
          },
          {
            "name": "parent",
            "type": "object",
            "interface": "wl_surface",
            "summary": "parent surface"
          },
          {
            "name": "x",
            "type": "int",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "surface-local y coordinate"
          },
          {
            "name": "flags",
            "type": "uint",
            "enum": "transient",
            "summary": "transient surface behavior"
          }
        ]
      },
      {
        "name": "set_maximized",
        "description": "\n\tMap the surface as a maximized surface.\n\n\tIf an output parameter is given then the surface will be\n\tmaximized on that output. If the client does not specify the\n\toutput then the compositor will apply its policy - usually\n\tchoosing the output on which the surface has the biggest surface\n\tarea.\n\n\tThe compositor will reply with a configure event telling\n\tthe expected new surface size. The operation is completed\n\ton the next buffer attach to this surface.\n\n\tA maximized surface typically fills the entire output it is\n\tbound to, except for desktop elements such as panels. This is\n\tthe main difference between a maximized shell surface and a\n\tfullscreen shell surface.\n\n\tThe details depend on the compositor implementation.\n      ",
        "summary": "make the surface a maximized surface",
        "args": [
          {
            "name": "output",
            "type": "object",
            "interface": "wl_output",
            "allow-null": "true",
            "summary": "output on which the surface is to be maximized"
          }
        ]
      },
      {
        "name": "set_title",
        "description": "\n\tSet a short title for the surface.\n\n\tThis string may be used to identify the surface in a task bar,\n\twindow list, or other user interface elements provided by the\n\tcompositor.\n\n\tThe string must be encoded in UTF-8.\n      ",
        "summary": "set surface title",
        "args": [
          {
            "name": "title",
            "type": "string",
            "summary": "surface title"
          }
        ]
      },
      {
        "name": "set_class",
        "description": "\n\tSet a class for the surface.\n\n\tThe surface class identifies the general class of applications\n\tto which the surface belongs. A common convention is to use the\n\tfile name (or the full path if it is a non-standard location) of\n\tthe application's .desktop file as the class.\n      ",
        "summary": "set surface class",
        "args": [
          {
            "name": "class_",
            "type": "string",
            "summary": "surface class"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "ping",
        "description": "\n\tPing a client to check if it is receiving events and sending\n\trequests. A client is expected to reply with a pong request.\n      ",
        "summary": "ping client",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the ping"
          }
        ]
      },
      {
        "name": "configure",
        "description": "\n\tThe configure event asks the client to resize its surface.\n\n\tThe size is a hint, in the sense that the client is free to\n\tignore it if it doesn't resize, pick a smaller size (to\n\tsatisfy aspect ratio or resize in steps of NxM pixels).\n\n\tThe edges parameter provides a hint about how the surface\n\twas resized. The client may use this information to decide\n\thow to adjust its content to the new size (e.g. a scrolling\n\tarea might adjust its content position to leave the viewable\n\tcontent unmoved).\n\n\tThe client is free to dismiss all but the last configure\n\tevent it received.\n\n\tThe width and height arguments specify the size of the window\n\tin surface-local coordinates.\n      ",
        "summary": "suggest resize",
        "args": [
          {
            "name": "edges",
            "type": "uint",
            "enum": "resize",
            "summary": "how the surface was resized"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "new width of the surface"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "new height of the surface"
          }
        ]
      },
      {
        "name": "popup_done",
        "description": "\n\tThe popup_done event is sent out when a popup grab is broken,\n\tthat is, when the user clicks a surface that doesn't belong\n\tto the client owning the popup surface.\n      ",
        "summary": "popup interaction is done",
        "args": []
      }
    ],
    "enums": {
      "resize": [
        {
          "name": "none",
          "value": 0,
          "summary": "no edge"
        },
        {
          "name": "top",
          "value": 1,
          "summary": "top edge"
        },
        {
          "name": "bottom",
          "value": 2,
          "summary": "bottom edge"
        },
        {
          "name": "left",
          "value": 4,
          "summary": "left edge"
        },
        {
          "name": "top_left",
          "value": 5,
          "summary": "top and left edges"
        },
        {
          "name": "bottom_left",
          "value": 6,
          "summary": "bottom and left edges"
        },
        {
          "name": "right",
          "value": 8,
          "summary": "right edge"
        },
        {
          "name": "top_right",
          "value": 9,
          "summary": "top and right edges"
        },
        {
          "name": "bottom_right",
          "value": 10,
          "summary": "bottom and right edges"
        }
      ],
      "transient": [
        {
          "name": "inactive",
          "value": 1,
          "summary": "do not set keyboard focus"
        }
      ],
      "fullscreen_method": [
        {
          "name": "default",
          "value": 0,
          "summary": "no preference, apply default policy"
        },
        {
          "name": "scale",
          "value": 1,
          "summary": "scale, preserve the surface's aspect ratio and center on output"
        },
        {
          "name": "driver",
          "value": 2,
          "summary": "switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"
        },
        {
          "name": "fill",
          "value": 3,
          "summary": "no upscaling, center on output and add black borders to compensate size mismatch"
        }
      ]
    }
  },
  {
    "name": "wl_surface",
    "version": 4,
    "description": "\n      A surface is a rectangular area that may be displayed on zero\n      or more outputs, and shown any number of times at the compositor's\n      discretion. They can present wl_buffers, receive user input, and\n      define a local coordinate system.\n\n      The size of a surface (and relative positions on it) is described\n      in surface-local coordinates, which may differ from the buffer\n      coordinates of the pixel content, in case a buffer_transform\n      or a buffer_scale is used.\n\n      A surface without a \"role\" is fairly useless: a compositor does\n      not know where, when or how to present it. The role is the\n      purpose of a wl_surface. Examples of roles are a cursor for a\n      pointer (as set by wl_pointer.set_cursor), a drag icon\n      (wl_data_device.start_drag), a sub-surface\n      (wl_subcompositor.get_subsurface), and a window as defined by a\n      shell protocol (e.g. wl_shell.get_shell_surface).\n\n      A surface can have only one role at a time. Initially a\n      wl_surface does not have a role. Once a wl_surface is given a\n      role, it is set permanently for the whole lifetime of the\n      wl_surface object. Giving the current role again is allowed,\n      unless explicitly forbidden by the relevant interface\n      specification.\n\n      Surface roles are given by requests in other interfaces such as\n      wl_pointer.set_cursor. The request should explicitly mention\n      that this request gives a role to a wl_surface. Often, this\n      request also creates a new protocol object that represents the\n      role and adds additional functionality to wl_surface. When a\n      client wants to destroy a wl_surface, they must destroy this 'role\n      object' before the wl_surface.\n\n      Destroying the role object does not remove the role from the\n      wl_surface, but it may stop the wl_surface from \"playing the role\".\n      For instance, if a wl_subsurface object is destroyed, the wl_surface\n      it was created for will be unmapped and forget its position and\n      z-order. It is allowed to create a wl_subsurface for the same\n      wl_surface again, but it is not allowed to use the wl_surface as\n      a cursor (cursor is a different role than sub-surface, and role\n      switching is not allowed).\n    ",
    "summary": "an onscreen surface",
    "requests": [
      {
        "name": "destroy",
        "description": "\n\tDeletes the surface and invalidates its object ID.\n      ",
        "summary": "delete surface",
        "args": []
      },
      {
        "name": "attach",
        "description": "\n\tSet a buffer as the content of this surface.\n\n\tThe new size of the surface is calculated based on the buffer\n\tsize transformed by the inverse buffer_transform and the\n\tinverse buffer_scale. This means that at commit time the supplied\n\tbuffer size must be an integer multiple of the buffer_scale. If\n\tthat's not the case, an invalid_size error is sent.\n\n\tThe x and y arguments specify the location of the new pending\n\tbuffer's upper left corner, relative to the current buffer's upper\n\tleft corner, in surface-local coordinates. In other words, the\n\tx and y, combined with the new surface size define in which\n\tdirections the surface's size changes.\n\n\tSurface contents are double-buffered state, see wl_surface.commit.\n\n\tThe initial surface contents are void; there is no content.\n\twl_surface.attach assigns the given wl_buffer as the pending\n\twl_buffer. wl_surface.commit makes the pending wl_buffer the new\n\tsurface contents, and the size of the surface becomes the size\n\tcalculated from the wl_buffer, as described above. After commit,\n\tthere is no pending buffer until the next attach.\n\n\tCommitting a pending wl_buffer allows the compositor to read the\n\tpixels in the wl_buffer. The compositor may access the pixels at\n\tany time after the wl_surface.commit request. When the compositor\n\twill not access the pixels anymore, it will send the\n\twl_buffer.release event. Only after receiving wl_buffer.release,\n\tthe client may reuse the wl_buffer. A wl_buffer that has been\n\tattached and then replaced by another attach instead of committed\n\twill not receive a release event, and is not used by the\n\tcompositor.\n\n\tIf a pending wl_buffer has been committed to more than one wl_surface,\n\tthe delivery of wl_buffer.release events becomes undefined. A well\n\tbehaved client should not rely on wl_buffer.release events in this\n\tcase. Alternatively, a client could create multiple wl_buffer objects\n\tfrom the same backing storage or use wp_linux_buffer_release.\n\n\tDestroying the wl_buffer after wl_buffer.release does not change\n\tthe surface contents. However, if the client destroys the\n\twl_buffer before receiving the wl_buffer.release event, the surface\n\tcontents become undefined immediately.\n\n\tIf wl_surface.attach is sent with a NULL wl_buffer, the\n\tfollowing wl_surface.commit will remove the surface content.\n      ",
        "summary": "set the surface contents",
        "args": [
          {
            "name": "buffer",
            "type": "object",
            "interface": "wl_buffer",
            "allow-null": "true",
            "summary": "buffer of surface contents"
          },
          {
            "name": "x",
            "type": "int",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "damage",
        "description": "\n\tThis request is used to describe the regions where the pending\n\tbuffer is different from the current surface contents, and where\n\tthe surface therefore needs to be repainted. The compositor\n\tignores the parts of the damage that fall outside of the surface.\n\n\tDamage is double-buffered state, see wl_surface.commit.\n\n\tThe damage rectangle is specified in surface-local coordinates,\n\twhere x and y specify the upper left corner of the damage rectangle.\n\n\tThe initial value for pending damage is empty: no damage.\n\twl_surface.damage adds pending damage: the new pending damage\n\tis the union of old pending damage and the given rectangle.\n\n\twl_surface.commit assigns pending damage as the current damage,\n\tand clears pending damage. The server will clear the current\n\tdamage as it repaints the surface.\n\n\tNote! New clients should not use this request. Instead damage can be\n\tposted with wl_surface.damage_buffer which uses buffer coordinates\n\tinstead of surface coordinates.\n      ",
        "summary": "mark part of the surface damaged",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "surface-local y coordinate"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "width of damage rectangle"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "height of damage rectangle"
          }
        ]
      },
      {
        "name": "frame",
        "description": "\n\tRequest a notification when it is a good time to start drawing a new\n\tframe, by creating a frame callback. This is useful for throttling\n\tredrawing operations, and driving animations.\n\n\tWhen a client is animating on a wl_surface, it can use the 'frame'\n\trequest to get notified when it is a good time to draw and commit the\n\tnext frame of animation. If the client commits an update earlier than\n\tthat, it is likely that some updates will not make it to the display,\n\tand the client is wasting resources by drawing too often.\n\n\tThe frame request will take effect on the next wl_surface.commit.\n\tThe notification will only be posted for one frame unless\n\trequested again. For a wl_surface, the notifications are posted in\n\tthe order the frame requests were committed.\n\n\tThe server must send the notifications so that a client\n\twill not send excessive updates, while still allowing\n\tthe highest possible update rate for clients that wait for the reply\n\tbefore drawing again. The server should give some time for the client\n\tto draw and commit after sending the frame callback events to let it\n\thit the next output refresh.\n\n\tA server should avoid signaling the frame callbacks if the\n\tsurface is not visible in any way, e.g. the surface is off-screen,\n\tor completely obscured by other opaque surfaces.\n\n\tThe object returned by this request will be destroyed by the\n\tcompositor after the callback is fired and as such the client must not\n\tattempt to use it after that point.\n\n\tThe callback_data passed in the callback is the current time, in\n\tmilliseconds, with an undefined base.\n      ",
        "summary": "request a frame throttling hint",
        "args": [
          {
            "name": "callback",
            "type": "new_id",
            "interface": "wl_callback",
            "summary": "callback object for the frame request"
          }
        ]
      },
      {
        "name": "set_opaque_region",
        "description": "\n\tThis request sets the region of the surface that contains\n\topaque content.\n\n\tThe opaque region is an optimization hint for the compositor\n\tthat lets it optimize the redrawing of content behind opaque\n\tregions.  Setting an opaque region is not required for correct\n\tbehaviour, but marking transparent content as opaque will result\n\tin repaint artifacts.\n\n\tThe opaque region is specified in surface-local coordinates.\n\n\tThe compositor ignores the parts of the opaque region that fall\n\toutside of the surface.\n\n\tOpaque region is double-buffered state, see wl_surface.commit.\n\n\twl_surface.set_opaque_region changes the pending opaque region.\n\twl_surface.commit copies the pending region to the current region.\n\tOtherwise, the pending and current regions are never changed.\n\n\tThe initial value for an opaque region is empty. Setting the pending\n\topaque region has copy semantics, and the wl_region object can be\n\tdestroyed immediately. A NULL wl_region causes the pending opaque\n\tregion to be set to empty.\n      ",
        "summary": "set opaque region",
        "args": [
          {
            "name": "region",
            "type": "object",
            "interface": "wl_region",
            "allow-null": "true",
            "summary": "opaque region of the surface"
          }
        ]
      },
      {
        "name": "set_input_region",
        "description": "\n\tThis request sets the region of the surface that can receive\n\tpointer and touch events.\n\n\tInput events happening outside of this region will try the next\n\tsurface in the server surface stack. The compositor ignores the\n\tparts of the input region that fall outside of the surface.\n\n\tThe input region is specified in surface-local coordinates.\n\n\tInput region is double-buffered state, see wl_surface.commit.\n\n\twl_surface.set_input_region changes the pending input region.\n\twl_surface.commit copies the pending region to the current region.\n\tOtherwise the pending and current regions are never changed,\n\texcept cursor and icon surfaces are special cases, see\n\twl_pointer.set_cursor and wl_data_device.start_drag.\n\n\tThe initial value for an input region is infinite. That means the\n\twhole surface will accept input. Setting the pending input region\n\thas copy semantics, and the wl_region object can be destroyed\n\timmediately. A NULL wl_region causes the input region to be set\n\tto infinite.\n      ",
        "summary": "set input region",
        "args": [
          {
            "name": "region",
            "type": "object",
            "interface": "wl_region",
            "allow-null": "true",
            "summary": "input region of the surface"
          }
        ]
      },
      {
        "name": "commit",
        "description": "\n\tSurface state (input, opaque, and damage regions, attached buffers,\n\tetc.) is double-buffered. Protocol requests modify the pending state,\n\tas opposed to the current state in use by the compositor. A commit\n\trequest atomically applies all pending state, replacing the current\n\tstate. After commit, the new pending state is as documented for each\n\trelated request.\n\n\tOn commit, a pending wl_buffer is applied first, and all other state\n\tsecond. This means that all coordinates in double-buffered state are\n\trelative to the new wl_buffer coming into use, except for\n\twl_surface.attach itself. If there is no pending wl_buffer, the\n\tcoordinates are relative to the current surface contents.\n\n\tAll requests that need a commit to become effective are documented\n\tto affect double-buffered state.\n\n\tOther interfaces may add further double-buffered surface state.\n      ",
        "summary": "commit pending surface state",
        "args": []
      },
      {
        "name": "set_buffer_transform",
        "description": "\n\tThis request sets an optional transformation on how the compositor\n\tinterprets the contents of the buffer attached to the surface. The\n\taccepted values for the transform parameter are the values for\n\twl_output.transform.\n\n\tBuffer transform is double-buffered state, see wl_surface.commit.\n\n\tA newly created surface has its buffer transformation set to normal.\n\n\twl_surface.set_buffer_transform changes the pending buffer\n\ttransformation. wl_surface.commit copies the pending buffer\n\ttransformation to the current one. Otherwise, the pending and current\n\tvalues are never changed.\n\n\tThe purpose of this request is to allow clients to render content\n\taccording to the output transform, thus permitting the compositor to\n\tuse certain optimizations even if the display is rotated. Using\n\thardware overlays and scanning out a client buffer for fullscreen\n\tsurfaces are examples of such optimizations. Those optimizations are\n\thighly dependent on the compositor implementation, so the use of this\n\trequest should be considered on a case-by-case basis.\n\n\tNote that if the transform value includes 90 or 270 degree rotation,\n\tthe width of the buffer will become the surface height and the height\n\tof the buffer will become the surface width.\n\n\tIf transform is not one of the values from the\n\twl_output.transform enum the invalid_transform protocol error\n\tis raised.\n      ",
        "summary": "sets the buffer transformation",
        "args": [
          {
            "name": "transform",
            "type": "int",
            "enum": "wl_output.transform",
            "summary": "transform for interpreting buffer contents"
          }
        ]
      },
      {
        "name": "set_buffer_scale",
        "description": "\n\tThis request sets an optional scaling factor on how the compositor\n\tinterprets the contents of the buffer attached to the window.\n\n\tBuffer scale is double-buffered state, see wl_surface.commit.\n\n\tA newly created surface has its buffer scale set to 1.\n\n\twl_surface.set_buffer_scale changes the pending buffer scale.\n\twl_surface.commit copies the pending buffer scale to the current one.\n\tOtherwise, the pending and current values are never changed.\n\n\tThe purpose of this request is to allow clients to supply higher\n\tresolution buffer data for use on high resolution outputs. It is\n\tintended that you pick the same buffer scale as the scale of the\n\toutput that the surface is displayed on. This means the compositor\n\tcan avoid scaling when rendering the surface on that output.\n\n\tNote that if the scale is larger than 1, then you have to attach\n\ta buffer that is larger (by a factor of scale in each dimension)\n\tthan the desired surface size.\n\n\tIf scale is not positive the invalid_scale protocol error is\n\traised.\n      ",
        "summary": "sets the buffer scaling factor",
        "args": [
          {
            "name": "scale",
            "type": "int",
            "summary": "positive scale for interpreting buffer contents"
          }
        ]
      },
      {
        "name": "damage_buffer",
        "description": "\n\tThis request is used to describe the regions where the pending\n\tbuffer is different from the current surface contents, and where\n\tthe surface therefore needs to be repainted. The compositor\n\tignores the parts of the damage that fall outside of the surface.\n\n\tDamage is double-buffered state, see wl_surface.commit.\n\n\tThe damage rectangle is specified in buffer coordinates,\n\twhere x and y specify the upper left corner of the damage rectangle.\n\n\tThe initial value for pending damage is empty: no damage.\n\twl_surface.damage_buffer adds pending damage: the new pending\n\tdamage is the union of old pending damage and the given rectangle.\n\n\twl_surface.commit assigns pending damage as the current damage,\n\tand clears pending damage. The server will clear the current\n\tdamage as it repaints the surface.\n\n\tThis request differs from wl_surface.damage in only one way - it\n\ttakes damage in buffer coordinates instead of surface-local\n\tcoordinates. While this generally is more intuitive than surface\n\tcoordinates, it is especially desirable when using wp_viewport\n\tor when a drawing library (like EGL) is unaware of buffer scale\n\tand buffer transform.\n\n\tNote: Because buffer transformation changes and damage requests may\n\tbe interleaved in the protocol stream, it is impossible to determine\n\tthe actual mapping between surface and buffer damage until\n\twl_surface.commit time. Therefore, compositors wishing to take both\n\tkinds of damage into account will have to accumulate damage from the\n\ttwo requests separately and only transform from one to the other\n\tafter receiving the wl_surface.commit.\n      ",
        "summary": "mark part of the surface damaged using buffer coordinates",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "buffer-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "buffer-local y coordinate"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "width of damage rectangle"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "height of damage rectangle"
          }
        ]
      }
    ],
    "events": [
      {
        "name": "enter",
        "description": "\n\tThis is emitted whenever a surface's creation, movement, or resizing\n\tresults in some part of it being within the scanout region of an\n\toutput.\n\n\tNote that a surface may be overlapping with zero or more outputs.\n      ",
        "summary": "surface enters an output",
        "args": [
          {
            "name": "output",
            "type": "object",
            "interface": "wl_output",
            "summary": "output entered by the surface"
          }
        ]
      },
      {
        "name": "leave",
        "description": "\n\tThis is emitted whenever a surface's creation, movement, or resizing\n\tresults in it no longer having any part of it within the scanout region\n\tof an output.\n\n\tClients should not use the number of outputs the surface is on for frame\n\tthrottling purposes. The surface might be hidden even if no leave event\n\thas been sent, and the compositor might expect new surface content\n\tupdates even if no enter event has been sent. The frame event should be\n\tused instead.\n      ",
        "summary": "surface leaves an output",
        "args": [
          {
            "name": "output",
            "type": "object",
            "interface": "wl_output",
            "summary": "output left by the surface"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "invalid_scale",
          "value": 0,
          "summary": "buffer scale value is invalid"
        },
        {
          "name": "invalid_transform",
          "value": 1,
          "summary": "buffer transform value is invalid"
        },
        {
          "name": "invalid_size",
          "value": 2,
          "summary": "buffer size is invalid"
        }
      ]
    }
  },
  {
    "name": "wl_seat",
    "version": 7,
    "description": "\n      A seat is a group of keyboards, pointer and touch devices. This\n      object is published as a global during start up, or when such a\n      device is hot plugged.  A seat typically has a pointer and\n      maintains a keyboard focus and a pointer focus.\n    ",
    "summary": "group of input devices",
    "requests": [
      {
        "name": "get_pointer",
        "description": "\n\tThe ID provided will be initialized to the wl_pointer interface\n\tfor this seat.\n\n\tThis request only takes effect if the seat has the pointer\n\tcapability, or has had the pointer capability in the past.\n\tIt is a protocol violation to issue this request on a seat that has\n\tnever had the pointer capability. The missing_capability error will\n\tbe sent in this case.\n      ",
        "summary": "return pointer object",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_pointer",
            "summary": "seat pointer"
          }
        ]
      },
      {
        "name": "get_keyboard",
        "description": "\n\tThe ID provided will be initialized to the wl_keyboard interface\n\tfor this seat.\n\n\tThis request only takes effect if the seat has the keyboard\n\tcapability, or has had the keyboard capability in the past.\n\tIt is a protocol violation to issue this request on a seat that has\n\tnever had the keyboard capability. The missing_capability error will\n\tbe sent in this case.\n      ",
        "summary": "return keyboard object",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_keyboard",
            "summary": "seat keyboard"
          }
        ]
      },
      {
        "name": "get_touch",
        "description": "\n\tThe ID provided will be initialized to the wl_touch interface\n\tfor this seat.\n\n\tThis request only takes effect if the seat has the touch\n\tcapability, or has had the touch capability in the past.\n\tIt is a protocol violation to issue this request on a seat that has\n\tnever had the touch capability. The missing_capability error will\n\tbe sent in this case.\n      ",
        "summary": "return touch object",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_touch",
            "summary": "seat touch interface"
          }
        ]
      },
      {
        "name": "release",
        "description": "\n\tUsing this request a client can tell the server that it is not going to\n\tuse the seat object anymore.\n      ",
        "summary": "release the seat object",
        "args": []
      }
    ],
    "events": [
      {
        "name": "capabilities",
        "description": "\n\tThis is emitted whenever a seat gains or loses the pointer,\n\tkeyboard or touch capabilities.  The argument is a capability\n\tenum containing the complete set of capabilities this seat has.\n\n\tWhen the pointer capability is added, a client may create a\n\twl_pointer object using the wl_seat.get_pointer request. This object\n\twill receive pointer events until the capability is removed in the\n\tfuture.\n\n\tWhen the pointer capability is removed, a client should destroy the\n\twl_pointer objects associated with the seat where the capability was\n\tremoved, using the wl_pointer.release request. No further pointer\n\tevents will be received on these objects.\n\n\tIn some compositors, if a seat regains the pointer capability and a\n\tclient has a previously obtained wl_pointer object of version 4 or\n\tless, that object may start sending pointer events again. This\n\tbehavior is considered a misinterpretation of the intended behavior\n\tand must not be relied upon by the client. wl_pointer objects of\n\tversion 5 or later must not send events if created before the most\n\trecent event notifying the client of an added pointer capability.\n\n\tThe above behavior also applies to wl_keyboard and wl_touch with the\n\tkeyboard and touch capabilities, respectively.\n      ",
        "summary": "seat capabilities changed",
        "args": [
          {
            "name": "capabilities",
            "type": "uint",
            "enum": "capability",
            "summary": "capabilities of the seat"
          }
        ]
      },
      {
        "name": "name",
        "description": "\n\tIn a multiseat configuration this can be used by the client to help\n\tidentify which physical devices the seat represents. Based on\n\tthe seat configuration used by the compositor.\n      ",
        "summary": "unique identifier for this seat",
        "args": [
          {
            "name": "name",
            "type": "string",
            "summary": "seat identifier"
          }
        ]
      }
    ],
    "enums": {
      "capability": [
        {
          "name": "pointer",
          "value": 1,
          "summary": "the seat has pointer devices"
        },
        {
          "name": "keyboard",
          "value": 2,
          "summary": "the seat has one or more keyboards"
        },
        {
          "name": "touch",
          "value": 4,
          "summary": "the seat has touch devices"
        }
      ],
      "error": [
        {
          "name": "missing_capability",
          "value": 0,
          "summary": "get_pointer, get_keyboard or get_touch called on seat without the matching capability"
        }
      ]
    }
  },
  {
    "name": "wl_pointer",
    "version": 7,
    "description": "\n      The wl_pointer interface represents one or more input devices,\n      such as mice, which control the pointer location and pointer_focus\n      of a seat.\n\n      The wl_pointer interface generates motion, enter and leave\n      events for the surfaces that the pointer is located over,\n      and button and axis events for button presses, button releases\n      and scrolling.\n    ",
    "summary": "pointer input device",
    "requests": [
      {
        "name": "set_cursor",
        "description": "\n\tSet the pointer surface, i.e., the surface that contains the\n\tpointer image (cursor). This request gives the surface the role\n\tof a cursor. If the surface already has another role, it raises\n\ta protocol error.\n\n\tThe cursor actually changes only if the pointer\n\tfocus for this device is one of the requesting client's surfaces\n\tor the surface parameter is the current pointer surface. If\n\tthere was a previous surface set with this request it is\n\treplaced. If surface is NULL, the pointer image is hidden.\n\n\tThe parameters hotspot_x and hotspot_y define the position of\n\tthe pointer surface relative to the pointer location. Its\n\ttop-left corner is always at (x, y) - (hotspot_x, hotspot_y),\n\twhere (x, y) are the coordinates of the pointer location, in\n\tsurface-local coordinates.\n\n\tOn surface.attach requests to the pointer surface, hotspot_x\n\tand hotspot_y are decremented by the x and y parameters\n\tpassed to the request. Attach must be confirmed by\n\twl_surface.commit as usual.\n\n\tThe hotspot can also be updated by passing the currently set\n\tpointer surface to this request with new values for hotspot_x\n\tand hotspot_y.\n\n\tThe current and pending input regions of the wl_surface are\n\tcleared, and wl_surface.set_input_region is ignored until the\n\twl_surface is no longer used as the cursor. When the use as a\n\tcursor ends, the current and pending input regions become\n\tundefined, and the wl_surface is unmapped.\n      ",
        "summary": "set the pointer surface",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the enter event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "allow-null": "true",
            "summary": "pointer surface"
          },
          {
            "name": "hotspot_x",
            "type": "int",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "hotspot_y",
            "type": "int",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "release",
        "description": "\n\tUsing this request a client can tell the server that it is not going to\n\tuse the pointer object anymore.\n\n\tThis request destroys the pointer proxy object, so clients must not call\n\twl_pointer_destroy() after using this request.\n      ",
        "summary": "release the pointer object",
        "args": []
      }
    ],
    "events": [
      {
        "name": "enter",
        "description": "\n\tNotification that this seat's pointer is focused on a certain\n\tsurface.\n\n\tWhen a seat's focus enters a surface, the pointer image\n\tis undefined and a client should respond to this event by setting\n\tan appropriate pointer image with the set_cursor request.\n      ",
        "summary": "enter event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the enter event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface entered by the pointer"
          },
          {
            "name": "surface_x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "surface_y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "leave",
        "description": "\n\tNotification that this seat's pointer is no longer focused on\n\ta certain surface.\n\n\tThe leave notification is sent before the enter notification\n\tfor the new focus.\n      ",
        "summary": "leave event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the leave event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface left by the pointer"
          }
        ]
      },
      {
        "name": "motion",
        "description": "\n\tNotification of pointer location change. The arguments\n\tsurface_x and surface_y are the location relative to the\n\tfocused surface.\n      ",
        "summary": "pointer motion event",
        "args": [
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "surface_x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "surface_y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "button",
        "description": "\n\tMouse button click and release notifications.\n\n\tThe location of the click is given by the last motion or\n\tenter event.\n\tThe time argument is a timestamp with millisecond\n\tgranularity, with an undefined base.\n\n\tThe button is a button code as defined in the Linux kernel's\n\tlinux/input-event-codes.h header file, e.g. BTN_LEFT.\n\n\tAny 16-bit button code value is reserved for future additions to the\n\tkernel's event code list. All other button codes above 0xFFFF are\n\tcurrently undefined but may be used in future versions of this\n\tprotocol.\n      ",
        "summary": "pointer button event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the button event"
          },
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "button",
            "type": "uint",
            "summary": "button that produced the event"
          },
          {
            "name": "state",
            "type": "uint",
            "enum": "button_state",
            "summary": "physical state of the button"
          }
        ]
      },
      {
        "name": "axis",
        "description": "\n\tScroll and other axis notifications.\n\n\tFor scroll events (vertical and horizontal scroll axes), the\n\tvalue parameter is the length of a vector along the specified\n\taxis in a coordinate space identical to those of motion events,\n\trepresenting a relative movement along the specified axis.\n\n\tFor devices that support movements non-parallel to axes multiple\n\taxis events will be emitted.\n\n\tWhen applicable, for example for touch pads, the server can\n\tchoose to emit scroll events where the motion vector is\n\tequivalent to a motion event vector.\n\n\tWhen applicable, a client can transform its content relative to the\n\tscroll distance.\n      ",
        "summary": "axis event",
        "args": [
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "axis",
            "type": "uint",
            "enum": "axis",
            "summary": "axis type"
          },
          {
            "name": "value",
            "type": "fixed",
            "summary": "length of vector in surface-local coordinate space"
          }
        ]
      },
      {
        "name": "frame",
        "description": "\n\tIndicates the end of a set of events that logically belong together.\n\tA client is expected to accumulate the data in all events within the\n\tframe before proceeding.\n\n\tAll wl_pointer events before a wl_pointer.frame event belong\n\tlogically together. For example, in a diagonal scroll motion the\n\tcompositor will send an optional wl_pointer.axis_source event, two\n\twl_pointer.axis events (horizontal and vertical) and finally a\n\twl_pointer.frame event. The client may use this information to\n\tcalculate a diagonal vector for scrolling.\n\n\tWhen multiple wl_pointer.axis events occur within the same frame,\n\tthe motion vector is the combined motion of all events.\n\tWhen a wl_pointer.axis and a wl_pointer.axis_stop event occur within\n\tthe same frame, this indicates that axis movement in one axis has\n\tstopped but continues in the other axis.\n\tWhen multiple wl_pointer.axis_stop events occur within the same\n\tframe, this indicates that these axes stopped in the same instance.\n\n\tA wl_pointer.frame event is sent for every logical event group,\n\teven if the group only contains a single wl_pointer event.\n\tSpecifically, a client may get a sequence: motion, frame, button,\n\tframe, axis, frame, axis_stop, frame.\n\n\tThe wl_pointer.enter and wl_pointer.leave events are logical events\n\tgenerated by the compositor and not the hardware. These events are\n\talso grouped by a wl_pointer.frame. When a pointer moves from one\n\tsurface to another, a compositor should group the\n\twl_pointer.leave event within the same wl_pointer.frame.\n\tHowever, a client must not rely on wl_pointer.leave and\n\twl_pointer.enter being in the same wl_pointer.frame.\n\tCompositor-specific policies may require the wl_pointer.leave and\n\twl_pointer.enter event being split across multiple wl_pointer.frame\n\tgroups.\n      ",
        "summary": "end of a pointer event sequence",
        "args": []
      },
      {
        "name": "axis_source",
        "description": "\n\tSource information for scroll and other axes.\n\n\tThis event does not occur on its own. It is sent before a\n\twl_pointer.frame event and carries the source information for\n\tall events within that frame.\n\n\tThe source specifies how this event was generated. If the source is\n\twl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be\n\tsent when the user lifts the finger off the device.\n\n\tIf the source is wl_pointer.axis_source.wheel,\n\twl_pointer.axis_source.wheel_tilt or\n\twl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may\n\tor may not be sent. Whether a compositor sends an axis_stop event\n\tfor these sources is hardware-specific and implementation-dependent;\n\tclients must not rely on receiving an axis_stop event for these\n\tscroll sources and should treat scroll sequences from these scroll\n\tsources as unterminated by default.\n\n\tThis event is optional. If the source is unknown for a particular\n\taxis event sequence, no event is sent.\n\tOnly one wl_pointer.axis_source event is permitted per frame.\n\n\tThe order of wl_pointer.axis_discrete and wl_pointer.axis_source is\n\tnot guaranteed.\n      ",
        "summary": "axis source event",
        "args": [
          {
            "name": "axis_source",
            "type": "uint",
            "enum": "axis_source",
            "summary": "source of the axis event"
          }
        ]
      },
      {
        "name": "axis_stop",
        "description": "\n\tStop notification for scroll and other axes.\n\n\tFor some wl_pointer.axis_source types, a wl_pointer.axis_stop event\n\tis sent to notify a client that the axis sequence has terminated.\n\tThis enables the client to implement kinetic scrolling.\n\tSee the wl_pointer.axis_source documentation for information on when\n\tthis event may be generated.\n\n\tAny wl_pointer.axis events with the same axis_source after this\n\tevent should be considered as the start of a new axis motion.\n\n\tThe timestamp is to be interpreted identical to the timestamp in the\n\twl_pointer.axis event. The timestamp value may be the same as a\n\tpreceding wl_pointer.axis event.\n      ",
        "summary": "axis stop event",
        "args": [
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "axis",
            "type": "uint",
            "enum": "axis",
            "summary": "the axis stopped with this event"
          }
        ]
      },
      {
        "name": "axis_discrete",
        "description": "\n\tDiscrete step information for scroll and other axes.\n\n\tThis event carries the axis value of the wl_pointer.axis event in\n\tdiscrete steps (e.g. mouse wheel clicks).\n\n\tThis event does not occur on its own, it is coupled with a\n\twl_pointer.axis event that represents this axis value on a\n\tcontinuous scale. The protocol guarantees that each axis_discrete\n\tevent is always followed by exactly one axis event with the same\n\taxis number within the same wl_pointer.frame. Note that the protocol\n\tallows for other events to occur between the axis_discrete and\n\tits coupled axis event, including other axis_discrete or axis\n\tevents.\n\n\tThis event is optional; continuous scrolling devices\n\tlike two-finger scrolling on touchpads do not have discrete\n\tsteps and do not generate this event.\n\n\tThe discrete value carries the directional information. e.g. a value\n\tof -2 is two steps towards the negative direction of this axis.\n\n\tThe axis number is identical to the axis number in the associated\n\taxis event.\n\n\tThe order of wl_pointer.axis_discrete and wl_pointer.axis_source is\n\tnot guaranteed.\n      ",
        "summary": "axis click event",
        "args": [
          {
            "name": "axis",
            "type": "uint",
            "enum": "axis",
            "summary": "axis type"
          },
          {
            "name": "discrete",
            "type": "int",
            "summary": "number of steps"
          }
        ]
      }
    ],
    "enums": {
      "error": [
        {
          "name": "role",
          "value": 0,
          "summary": "given wl_surface has another role"
        }
      ],
      "button_state": [
        {
          "name": "released",
          "value": 0,
          "summary": "the button is not pressed"
        },
        {
          "name": "pressed",
          "value": 1,
          "summary": "the button is pressed"
        }
      ],
      "axis": [
        {
          "name": "vertical_scroll",
          "value": 0,
          "summary": "vertical axis"
        },
        {
          "name": "horizontal_scroll",
          "value": 1,
          "summary": "horizontal axis"
        }
      ],
      "axis_source": [
        {
          "name": "wheel",
          "value": 0,
          "summary": "a physical wheel rotation"
        },
        {
          "name": "finger",
          "value": 1,
          "summary": "finger on a touch surface"
        },
        {
          "name": "continuous",
          "value": 2,
          "summary": "continuous coordinate space"
        },
        {
          "name": "wheel_tilt",
          "value": 3,
          "summary": "a physical wheel tilt"
        }
      ]
    }
  },
  {
    "name": "wl_keyboard",
    "version": 7,
    "description": "\n      The wl_keyboard interface represents one or more keyboards\n      associated with a seat.\n    ",
    "summary": "keyboard input device",
    "requests": [
      {
        "name": "release",
        "summary": "release the keyboard object",
        "args": []
      }
    ],
    "events": [
      {
        "name": "keymap",
        "description": "\n\tThis event provides a file descriptor to the client which can be\n\tmemory-mapped to provide a keyboard mapping description.\n\n\tFrom version 7 onwards, the fd must be mapped with MAP_PRIVATE by\n\tthe recipient, as MAP_SHARED may fail.\n      ",
        "summary": "keyboard mapping",
        "args": [
          {
            "name": "format",
            "type": "uint",
            "enum": "keymap_format",
            "summary": "keymap format"
          },
          {
            "name": "fd",
            "type": "fd",
            "summary": "keymap file descriptor"
          },
          {
            "name": "size",
            "type": "uint",
            "summary": "keymap size, in bytes"
          }
        ]
      },
      {
        "name": "enter",
        "description": "\n\tNotification that this seat's keyboard focus is on a certain\n\tsurface.\n\n\tThe compositor must send the wl_keyboard.modifiers event after this\n\tevent.\n      ",
        "summary": "enter event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the enter event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface gaining keyboard focus"
          },
          {
            "name": "keys",
            "type": "array",
            "summary": "the currently pressed keys"
          }
        ]
      },
      {
        "name": "leave",
        "description": "\n\tNotification that this seat's keyboard focus is no longer on\n\ta certain surface.\n\n\tThe leave notification is sent before the enter notification\n\tfor the new focus.\n\n\tAfter this event client must assume that all keys, including modifiers,\n\tare lifted and also it must stop key repeating if there's some going on.\n      ",
        "summary": "leave event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the leave event"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface that lost keyboard focus"
          }
        ]
      },
      {
        "name": "key",
        "description": "\n\tA key was pressed or released.\n\tThe time argument is a timestamp with millisecond\n\tgranularity, with an undefined base.\n\n\tThe key is a platform-specific key code that can be interpreted\n\tby feeding it to the keyboard mapping (see the keymap event).\n\n\tIf this event produces a change in modifiers, then the resulting\n\twl_keyboard.modifiers event must be sent after this event.\n      ",
        "summary": "key event",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the key event"
          },
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "key",
            "type": "uint",
            "summary": "key that produced the event"
          },
          {
            "name": "state",
            "type": "uint",
            "enum": "key_state",
            "summary": "physical state of the key"
          }
        ]
      },
      {
        "name": "modifiers",
        "description": "\n\tNotifies clients that the modifier and/or group state has\n\tchanged, and it should update its local state.\n      ",
        "summary": "modifier and group state",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the modifiers event"
          },
          {
            "name": "mods_depressed",
            "type": "uint",
            "summary": "depressed modifiers"
          },
          {
            "name": "mods_latched",
            "type": "uint",
            "summary": "latched modifiers"
          },
          {
            "name": "mods_locked",
            "type": "uint",
            "summary": "locked modifiers"
          },
          {
            "name": "group",
            "type": "uint",
            "summary": "keyboard layout"
          }
        ]
      },
      {
        "name": "repeat_info",
        "description": "\n\tInforms the client about the keyboard's repeat rate and delay.\n\n\tThis event is sent as soon as the wl_keyboard object has been created,\n\tand is guaranteed to be received by the client before any key press\n\tevent.\n\n\tNegative values for either rate or delay are illegal. A rate of zero\n\twill disable any repeating (regardless of the value of delay).\n\n\tThis event can be sent later on as well with a new value if necessary,\n\tso clients should continue listening for the event past the creation\n\tof wl_keyboard.\n      ",
        "summary": "repeat rate and delay",
        "args": [
          {
            "name": "rate",
            "type": "int",
            "summary": "the rate of repeating keys in characters per second"
          },
          {
            "name": "delay",
            "type": "int",
            "summary": "delay in milliseconds since key down until repeating starts"
          }
        ]
      }
    ],
    "enums": {
      "keymap_format": [
        {
          "name": "no_keymap",
          "value": 0,
          "summary": "no keymap; client must understand how to interpret the raw keycode"
        },
        {
          "name": "xkb_v1",
          "value": 1,
          "summary": "libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode"
        }
      ],
      "key_state": [
        {
          "name": "released",
          "value": 0,
          "summary": "key is not pressed"
        },
        {
          "name": "pressed",
          "value": 1,
          "summary": "key is pressed"
        }
      ]
    }
  },
  {
    "name": "wl_touch",
    "version": 7,
    "description": "\n      The wl_touch interface represents a touchscreen\n      associated with a seat.\n\n      Touch interactions can consist of one or more contacts.\n      For each contact, a series of events is generated, starting\n      with a down event, followed by zero or more motion events,\n      and ending with an up event. Events relating to the same\n      contact point can be identified by the ID of the sequence.\n    ",
    "summary": "touchscreen input device",
    "requests": [
      {
        "name": "release",
        "summary": "release the touch object",
        "args": []
      }
    ],
    "events": [
      {
        "name": "down",
        "description": "\n\tA new touch point has appeared on the surface. This touch point is\n\tassigned a unique ID. Future events from this touch point reference\n\tthis ID. The ID ceases to be valid after a touch up event and may be\n\treused in the future.\n      ",
        "summary": "touch down event and beginning of a touch sequence",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the touch down event"
          },
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "surface touched"
          },
          {
            "name": "id",
            "type": "int",
            "summary": "the unique ID of this touch point"
          },
          {
            "name": "x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "up",
        "description": "\n\tThe touch point has disappeared. No further events will be sent for\n\tthis touch point and the touch point's ID is released and may be\n\treused in a future touch down event.\n      ",
        "summary": "end of a touch event sequence",
        "args": [
          {
            "name": "serial",
            "type": "uint",
            "summary": "serial number of the touch up event"
          },
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "id",
            "type": "int",
            "summary": "the unique ID of this touch point"
          }
        ]
      },
      {
        "name": "motion",
        "description": "\n\tA touch point has changed coordinates.\n      ",
        "summary": "update of touch point coordinates",
        "args": [
          {
            "name": "time",
            "type": "uint",
            "summary": "timestamp with millisecond granularity"
          },
          {
            "name": "id",
            "type": "int",
            "summary": "the unique ID of this touch point"
          },
          {
            "name": "x",
            "type": "fixed",
            "summary": "surface-local x coordinate"
          },
          {
            "name": "y",
            "type": "fixed",
            "summary": "surface-local y coordinate"
          }
        ]
      },
      {
        "name": "frame",
        "description": "\n\tIndicates the end of a set of events that logically belong together.\n\tA client is expected to accumulate the data in all events within the\n\tframe before proceeding.\n\n\tA wl_touch.frame terminates at least one event but otherwise no\n\tguarantee is provided about the set of events within a frame. A client\n\tmust assume that any state not updated in a frame is unchanged from the\n\tpreviously known state.\n      ",
        "summary": "end of touch frame event",
        "args": []
      },
      {
        "name": "cancel",
        "description": "\n\tSent if the compositor decides the touch stream is a global\n\tgesture. No further events are sent to the clients from that\n\tparticular gesture. Touch cancellation applies to all touch points\n\tcurrently active on this client's surface. The client is\n\tresponsible for finalizing the touch points, future touch points on\n\tthis surface may reuse the touch point ID.\n      ",
        "summary": "touch session cancelled",
        "args": []
      },
      {
        "name": "shape",
        "description": "\n\tSent when a touchpoint has changed its shape.\n\n\tThis event does not occur on its own. It is sent before a\n\twl_touch.frame event and carries the new shape information for\n\tany previously reported, or new touch points of that frame.\n\n\tOther events describing the touch point such as wl_touch.down,\n\twl_touch.motion or wl_touch.orientation may be sent within the\n\tsame wl_touch.frame. A client should treat these events as a single\n\tlogical touch point update. The order of wl_touch.shape,\n\twl_touch.orientation and wl_touch.motion is not guaranteed.\n\tA wl_touch.down event is guaranteed to occur before the first\n\twl_touch.shape event for this touch ID but both events may occur within\n\tthe same wl_touch.frame.\n\n\tA touchpoint shape is approximated by an ellipse through the major and\n\tminor axis length. The major axis length describes the longer diameter\n\tof the ellipse, while the minor axis length describes the shorter\n\tdiameter. Major and minor are orthogonal and both are specified in\n\tsurface-local coordinates. The center of the ellipse is always at the\n\ttouchpoint location as reported by wl_touch.down or wl_touch.move.\n\n\tThis event is only sent by the compositor if the touch device supports\n\tshape reports. The client has to make reasonable assumptions about the\n\tshape if it did not receive this event.\n      ",
        "summary": "update shape of touch point",
        "args": [
          {
            "name": "id",
            "type": "int",
            "summary": "the unique ID of this touch point"
          },
          {
            "name": "major",
            "type": "fixed",
            "summary": "length of the major axis in surface-local coordinates"
          },
          {
            "name": "minor",
            "type": "fixed",
            "summary": "length of the minor axis in surface-local coordinates"
          }
        ]
      },
      {
        "name": "orientation",
        "description": "\n\tSent when a touchpoint has changed its orientation.\n\n\tThis event does not occur on its own. It is sent before a\n\twl_touch.frame event and carries the new shape information for\n\tany previously reported, or new touch points of that frame.\n\n\tOther events describing the touch point such as wl_touch.down,\n\twl_touch.motion or wl_touch.shape may be sent within the\n\tsame wl_touch.frame. A client should treat these events as a single\n\tlogical touch point update. The order of wl_touch.shape,\n\twl_touch.orientation and wl_touch.motion is not guaranteed.\n\tA wl_touch.down event is guaranteed to occur before the first\n\twl_touch.orientation event for this touch ID but both events may occur\n\twithin the same wl_touch.frame.\n\n\tThe orientation describes the clockwise angle of a touchpoint's major\n\taxis to the positive surface y-axis and is normalized to the -180 to\n\t+180 degree range. The granularity of orientation depends on the touch\n\tdevice, some devices only support binary rotation values between 0 and\n\t90 degrees.\n\n\tThis event is only sent by the compositor if the touch device supports\n\torientation reports.\n      ",
        "summary": "update orientation of touch point",
        "args": [
          {
            "name": "id",
            "type": "int",
            "summary": "the unique ID of this touch point"
          },
          {
            "name": "orientation",
            "type": "fixed",
            "summary": "angle between major axis and positive surface y-axis in degrees"
          }
        ]
      }
    ],
    "enums": {}
  },
  {
    "name": "wl_output",
    "version": 3,
    "description": "\n      An output describes part of the compositor geometry.  The\n      compositor works in the 'compositor coordinate system' and an\n      output corresponds to a rectangular area in that space that is\n      actually visible.  This typically corresponds to a monitor that\n      displays part of the compositor space.  This object is published\n      as global during start up, or when a monitor is hotplugged.\n    ",
    "summary": "compositor output region",
    "requests": [
      {
        "name": "release",
        "description": "\n\tUsing this request a client can tell the server that it is not going to\n\tuse the output object anymore.\n      ",
        "summary": "release the output object",
        "args": []
      }
    ],
    "events": [
      {
        "name": "geometry",
        "description": "\n\tThe geometry event describes geometric properties of the output.\n\tThe event is sent when binding to the output object and whenever\n\tany of the properties change.\n\n\tThe physical size can be set to zero if it doesn't make sense for this\n\toutput (e.g. for projectors or virtual outputs).\n\n\tNote: wl_output only advertises partial information about the output\n\tposition and identification. Some compositors, for instance those not\n\timplementing a desktop-style output layout or those exposing virtual\n\toutputs, might fake this information. Instead of using x and y, clients\n\tshould use xdg_output.logical_position. Instead of using make and model,\n\tclients should use xdg_output.name and xdg_output.description.\n      ",
        "summary": "properties of the output",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "x position within the global compositor space"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "y position within the global compositor space"
          },
          {
            "name": "physical_width",
            "type": "int",
            "summary": "width in millimeters of the output"
          },
          {
            "name": "physical_height",
            "type": "int",
            "summary": "height in millimeters of the output"
          },
          {
            "name": "subpixel",
            "type": "int",
            "enum": "subpixel",
            "summary": "subpixel orientation of the output"
          },
          {
            "name": "make",
            "type": "string",
            "summary": "textual description of the manufacturer"
          },
          {
            "name": "model",
            "type": "string",
            "summary": "textual description of the model"
          },
          {
            "name": "transform",
            "type": "int",
            "enum": "transform",
            "summary": "transform that maps framebuffer to output"
          }
        ]
      },
      {
        "name": "mode",
        "description": "\n\tThe mode event describes an available mode for the output.\n\n\tThe event is sent when binding to the output object and there\n\twill always be one mode, the current mode.  The event is sent\n\tagain if an output changes mode, for the mode that is now\n\tcurrent.  In other words, the current mode is always the last\n\tmode that was received with the current flag set.\n\n\tNon-current modes are deprecated. A compositor can decide to only\n\tadvertise the current mode and never send other modes. Clients\n\tshould not rely on non-current modes.\n\n\tThe size of a mode is given in physical hardware units of\n\tthe output device. This is not necessarily the same as\n\tthe output size in the global compositor space. For instance,\n\tthe output may be scaled, as described in wl_output.scale,\n\tor transformed, as described in wl_output.transform. Clients\n\twilling to retrieve the output size in the global compositor\n\tspace should use xdg_output.logical_size instead.\n\n\tThe vertical refresh rate can be set to zero if it doesn't make\n\tsense for this output (e.g. for virtual outputs).\n\n\tClients should not use the refresh rate to schedule frames. Instead,\n\tthey should use the wl_surface.frame event or the presentation-time\n\tprotocol.\n\n\tNote: this information is not always meaningful for all outputs. Some\n\tcompositors, such as those exposing virtual outputs, might fake the\n\trefresh rate or the size.\n      ",
        "summary": "advertise available modes for the output",
        "args": [
          {
            "name": "flags",
            "type": "uint",
            "enum": "mode",
            "summary": "bitfield of mode flags"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "width of the mode in hardware units"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "height of the mode in hardware units"
          },
          {
            "name": "refresh",
            "type": "int",
            "summary": "vertical refresh rate in mHz"
          }
        ]
      },
      {
        "name": "done",
        "description": "\n\tThis event is sent after all other properties have been\n\tsent after binding to the output object and after any\n\tother property changes done after that. This allows\n\tchanges to the output properties to be seen as\n\tatomic, even if they happen via multiple events.\n      ",
        "summary": "sent all information about output",
        "args": []
      },
      {
        "name": "scale",
        "description": "\n\tThis event contains scaling geometry information\n\tthat is not in the geometry event. It may be sent after\n\tbinding the output object or if the output scale changes\n\tlater. If it is not sent, the client should assume a\n\tscale of 1.\n\n\tA scale larger than 1 means that the compositor will\n\tautomatically scale surface buffers by this amount\n\twhen rendering. This is used for very high resolution\n\tdisplays where applications rendering at the native\n\tresolution would be too small to be legible.\n\n\tIt is intended that scaling aware clients track the\n\tcurrent output of a surface, and if it is on a scaled\n\toutput it should use wl_surface.set_buffer_scale with\n\tthe scale of the output. That way the compositor can\n\tavoid scaling the surface, and the client can supply\n\ta higher detail image.\n      ",
        "summary": "output scaling properties",
        "args": [
          {
            "name": "factor",
            "type": "int",
            "summary": "scaling factor of output"
          }
        ]
      }
    ],
    "enums": {
      "subpixel": [
        {
          "name": "unknown",
          "value": 0,
          "summary": "unknown geometry"
        },
        {
          "name": "none",
          "value": 1,
          "summary": "no geometry"
        },
        {
          "name": "horizontal_rgb",
          "value": 2,
          "summary": "horizontal RGB"
        },
        {
          "name": "horizontal_bgr",
          "value": 3,
          "summary": "horizontal BGR"
        },
        {
          "name": "vertical_rgb",
          "value": 4,
          "summary": "vertical RGB"
        },
        {
          "name": "vertical_bgr",
          "value": 5,
          "summary": "vertical BGR"
        }
      ],
      "transform": [
        {
          "name": "normal",
          "value": 0,
          "summary": "no transform"
        },
        {
          "name": "90",
          "value": 1,
          "summary": "90 degrees counter-clockwise"
        },
        {
          "name": "180",
          "value": 2,
          "summary": "180 degrees counter-clockwise"
        },
        {
          "name": "270",
          "value": 3,
          "summary": "270 degrees counter-clockwise"
        },
        {
          "name": "flipped",
          "value": 4,
          "summary": "180 degree flip around a vertical axis"
        },
        {
          "name": "flipped_90",
          "value": 5,
          "summary": "flip and rotate 90 degrees counter-clockwise"
        },
        {
          "name": "flipped_180",
          "value": 6,
          "summary": "flip and rotate 180 degrees counter-clockwise"
        },
        {
          "name": "flipped_270",
          "value": 7,
          "summary": "flip and rotate 270 degrees counter-clockwise"
        }
      ],
      "mode": [
        {
          "name": "current",
          "value": 1,
          "summary": "indicates this is the current mode"
        },
        {
          "name": "preferred",
          "value": 2,
          "summary": "indicates this is the preferred mode"
        }
      ]
    }
  },
  {
    "name": "wl_region",
    "version": 1,
    "description": "\n      A region object describes an area.\n\n      Region objects are used to describe the opaque and input\n      regions of a surface.\n    ",
    "summary": "region interface",
    "requests": [
      {
        "name": "destroy",
        "description": "\n\tDestroy the region.  This will invalidate the object ID.\n      ",
        "summary": "destroy region",
        "args": []
      },
      {
        "name": "add",
        "description": "\n\tAdd the specified rectangle to the region.\n      ",
        "summary": "add rectangle to region",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "region-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "region-local y coordinate"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "rectangle width"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "rectangle height"
          }
        ]
      },
      {
        "name": "subtract",
        "description": "\n\tSubtract the specified rectangle from the region.\n      ",
        "summary": "subtract rectangle from region",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "region-local x coordinate"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "region-local y coordinate"
          },
          {
            "name": "width",
            "type": "int",
            "summary": "rectangle width"
          },
          {
            "name": "height",
            "type": "int",
            "summary": "rectangle height"
          }
        ]
      }
    ],
    "events": [],
    "enums": {}
  },
  {
    "name": "wl_subcompositor",
    "version": 1,
    "description": "\n      The global interface exposing sub-surface compositing capabilities.\n      A wl_surface, that has sub-surfaces associated, is called the\n      parent surface. Sub-surfaces can be arbitrarily nested and create\n      a tree of sub-surfaces.\n\n      The root surface in a tree of sub-surfaces is the main\n      surface. The main surface cannot be a sub-surface, because\n      sub-surfaces must always have a parent.\n\n      A main surface with its sub-surfaces forms a (compound) window.\n      For window management purposes, this set of wl_surface objects is\n      to be considered as a single window, and it should also behave as\n      such.\n\n      The aim of sub-surfaces is to offload some of the compositing work\n      within a window from clients to the compositor. A prime example is\n      a video player with decorations and video in separate wl_surface\n      objects. This should allow the compositor to pass YUV video buffer\n      processing to dedicated overlay hardware when possible.\n    ",
    "summary": "sub-surface compositing",
    "requests": [
      {
        "name": "destroy",
        "description": "\n\tInforms the server that the client will not be using this\n\tprotocol object anymore. This does not affect any other\n\tobjects, wl_subsurface objects included.\n      ",
        "summary": "unbind from the subcompositor interface",
        "args": []
      },
      {
        "name": "get_subsurface",
        "description": "\n\tCreate a sub-surface interface for the given surface, and\n\tassociate it with the given parent surface. This turns a\n\tplain wl_surface into a sub-surface.\n\n\tThe to-be sub-surface must not already have another role, and it\n\tmust not have an existing wl_subsurface object. Otherwise a protocol\n\terror is raised.\n\n\tAdding sub-surfaces to a parent is a double-buffered operation on the\n\tparent (see wl_surface.commit). The effect of adding a sub-surface\n\tbecomes visible on the next time the state of the parent surface is\n\tapplied.\n\n\tThis request modifies the behaviour of wl_surface.commit request on\n\tthe sub-surface, see the documentation on wl_subsurface interface.\n      ",
        "summary": "give a surface the role sub-surface",
        "args": [
          {
            "name": "id",
            "type": "new_id",
            "interface": "wl_subsurface",
            "summary": "the new sub-surface object ID"
          },
          {
            "name": "surface",
            "type": "object",
            "interface": "wl_surface",
            "summary": "the surface to be turned into a sub-surface"
          },
          {
            "name": "parent",
            "type": "object",
            "interface": "wl_surface",
            "summary": "the parent surface"
          }
        ]
      }
    ],
    "events": [],
    "enums": {
      "error": [
        {
          "name": "bad_surface",
          "value": 0,
          "summary": "the to-be sub-surface is invalid"
        }
      ]
    }
  },
  {
    "name": "wl_subsurface",
    "version": 1,
    "description": "\n      An additional interface to a wl_surface object, which has been\n      made a sub-surface. A sub-surface has one parent surface. A\n      sub-surface's size and position are not limited to that of the parent.\n      Particularly, a sub-surface is not automatically clipped to its\n      parent's area.\n\n      A sub-surface becomes mapped, when a non-NULL wl_buffer is applied\n      and the parent surface is mapped. The order of which one happens\n      first is irrelevant. A sub-surface is hidden if the parent becomes\n      hidden, or if a NULL wl_buffer is applied. These rules apply\n      recursively through the tree of surfaces.\n\n      The behaviour of a wl_surface.commit request on a sub-surface\n      depends on the sub-surface's mode. The possible modes are\n      synchronized and desynchronized, see methods\n      wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\n      mode caches the wl_surface state to be applied when the parent's\n      state gets applied, and desynchronized mode applies the pending\n      wl_surface state directly. A sub-surface is initially in the\n      synchronized mode.\n\n      Sub-surfaces also have another kind of state, which is managed by\n      wl_subsurface requests, as opposed to wl_surface requests. This\n      state includes the sub-surface position relative to the parent\n      surface (wl_subsurface.set_position), and the stacking order of\n      the parent and its sub-surfaces (wl_subsurface.place_above and\n      .place_below). This state is applied when the parent surface's\n      wl_surface state is applied, regardless of the sub-surface's mode.\n      As the exception, set_sync and set_desync are effective immediately.\n\n      The main surface can be thought to be always in desynchronized mode,\n      since it does not have a parent in the sub-surfaces sense.\n\n      Even if a sub-surface is in desynchronized mode, it will behave as\n      in synchronized mode, if its parent surface behaves as in\n      synchronized mode. This rule is applied recursively throughout the\n      tree of surfaces. This means, that one can set a sub-surface into\n      synchronized mode, and then assume that all its child and grand-child\n      sub-surfaces are synchronized, too, without explicitly setting them.\n\n      If the wl_surface associated with the wl_subsurface is destroyed, the\n      wl_subsurface object becomes inert. Note, that destroying either object\n      takes effect immediately. If you need to synchronize the removal\n      of a sub-surface to the parent surface update, unmap the sub-surface\n      first by attaching a NULL wl_buffer, update parent, and then destroy\n      the sub-surface.\n\n      If the parent wl_surface object is destroyed, the sub-surface is\n      unmapped.\n    ",
    "summary": "sub-surface interface to a wl_surface",
    "requests": [
      {
        "name": "destroy",
        "description": "\n\tThe sub-surface interface is removed from the wl_surface object\n\tthat was turned into a sub-surface with a\n\twl_subcompositor.get_subsurface request. The wl_surface's association\n\tto the parent is deleted, and the wl_surface loses its role as\n\ta sub-surface. The wl_surface is unmapped immediately.\n      ",
        "summary": "remove sub-surface interface",
        "args": []
      },
      {
        "name": "set_position",
        "description": "\n\tThis schedules a sub-surface position change.\n\tThe sub-surface will be moved so that its origin (top left\n\tcorner pixel) will be at the location x, y of the parent surface\n\tcoordinate system. The coordinates are not restricted to the parent\n\tsurface area. Negative values are allowed.\n\n\tThe scheduled coordinates will take effect whenever the state of the\n\tparent surface is applied. When this happens depends on whether the\n\tparent surface is in synchronized mode or not. See\n\twl_subsurface.set_sync and wl_subsurface.set_desync for details.\n\n\tIf more than one set_position request is invoked by the client before\n\tthe commit of the parent surface, the position of a new request always\n\treplaces the scheduled position from any previous request.\n\n\tThe initial position is 0, 0.\n      ",
        "summary": "reposition the sub-surface",
        "args": [
          {
            "name": "x",
            "type": "int",
            "summary": "x coordinate in the parent surface"
          },
          {
            "name": "y",
            "type": "int",
            "summary": "y coordinate in the parent surface"
          }
        ]
      },
      {
        "name": "place_above",
        "description": "\n\tThis sub-surface is taken from the stack, and put back just\n\tabove the reference surface, changing the z-order of the sub-surfaces.\n\tThe reference surface must be one of the sibling surfaces, or the\n\tparent surface. Using any other surface, including this sub-surface,\n\twill cause a protocol error.\n\n\tThe z-order is double-buffered. Requests are handled in order and\n\tapplied immediately to a pending state. The final pending state is\n\tcopied to the active state the next time the state of the parent\n\tsurface is applied. When this happens depends on whether the parent\n\tsurface is in synchronized mode or not. See wl_subsurface.set_sync and\n\twl_subsurface.set_desync for details.\n\n\tA new sub-surface is initially added as the top-most in the stack\n\tof its siblings and parent.\n      ",
        "summary": "restack the sub-surface",
        "args": [
          {
            "name": "sibling",
            "type": "object",
            "interface": "wl_surface",
            "summary": "the reference surface"
          }
        ]
      },
      {
        "name": "place_below",
        "description": "\n\tThe sub-surface is placed just below the reference surface.\n\tSee wl_subsurface.place_above.\n      ",
        "summary": "restack the sub-surface",
        "args": [
          {
            "name": "sibling",
            "type": "object",
            "interface": "wl_surface",
            "summary": "the reference surface"
          }
        ]
      },
      {
        "name": "set_sync",
        "description": "\n\tChange the commit behaviour of the sub-surface to synchronized\n\tmode, also described as the parent dependent mode.\n\n\tIn synchronized mode, wl_surface.commit on a sub-surface will\n\taccumulate the committed state in a cache, but the state will\n\tnot be applied and hence will not change the compositor output.\n\tThe cached state is applied to the sub-surface immediately after\n\tthe parent surface's state is applied. This ensures atomic\n\tupdates of the parent and all its synchronized sub-surfaces.\n\tApplying the cached state will invalidate the cache, so further\n\tparent surface commits do not (re-)apply old state.\n\n\tSee wl_subsurface for the recursive effect of this mode.\n      ",
        "summary": "set sub-surface to synchronized mode",
        "args": []
      },
      {
        "name": "set_desync",
        "description": "\n\tChange the commit behaviour of the sub-surface to desynchronized\n\tmode, also described as independent or freely running mode.\n\n\tIn desynchronized mode, wl_surface.commit on a sub-surface will\n\tapply the pending state directly, without caching, as happens\n\tnormally with a wl_surface. Calling wl_surface.commit on the\n\tparent surface has no effect on the sub-surface's wl_surface\n\tstate. This mode allows a sub-surface to be updated on its own.\n\n\tIf cached state exists when wl_surface.commit is called in\n\tdesynchronized mode, the pending state is added to the cached\n\tstate, and applied as a whole. This invalidates the cache.\n\n\tNote: even if a sub-surface is set to desynchronized, a parent\n\tsub-surface may override it to behave as synchronized. For details,\n\tsee wl_subsurface.\n\n\tIf a surface's parent surface behaves as desynchronized, then\n\tthe cached state is applied on set_desync.\n      ",
        "summary": "set sub-surface to desynchronized mode",
        "args": []
      }
    ],
    "events": [],
    "enums": {
      "error": [
        {
          "name": "bad_surface",
          "value": 0,
          "summary": "wl_surface is not a sibling or the parent"
        }
      ]
    }
  }
]